/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 * OpenAPI spec version: 2.3.0
 */
import {
  z as zod
} from 'zod';


/**
 * List Containers
 * @summary List containers
 */
export const listContainersQueryLimitDefault = 20;export const listContainersQueryOrderDefault = "desc";

export const listContainersQueryParams = zod.object({
  "limit": zod.number().optional().describe('A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n'),
  "after": zod.string().optional().describe('A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n')
})

export const listContainersResponse = zod.object({
  "object": zod.any().describe('The type of object returned, must be \'list\'.'),
  "data": zod.array(zod.object({
  "id": zod.string().describe('Unique identifier for the container.'),
  "object": zod.string().describe('The type of this object.'),
  "name": zod.string().describe('Name of the container.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the container was created.'),
  "status": zod.string().describe('Status of the container (e.g., active, deleted).'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).optional().describe('The reference point for the expiration.'),
  "minutes": zod.number().optional().describe('The number of minutes after the anchor before the container expires.')
}).optional().describe('The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n')
})).describe('A list of containers.'),
  "first_id": zod.string().describe('The ID of the first container in the list.'),
  "last_id": zod.string().describe('The ID of the last container in the list.'),
  "has_more": zod.boolean().describe('Whether there are more containers available.')
})

/**
 * Create Container
 * @summary Create container
 */
export const createContainerBody = zod.object({
  "name": zod.string().describe('Name of the container to create.'),
  "file_ids": zod.array(zod.string()).optional().describe('IDs of files to copy to the container.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Time anchor for the expiration time. Currently only \'last_active_at\' is supported.'),
  "minutes": zod.number()
}).optional().describe('Container expiration time in seconds relative to the \'anchor\' time.')
})

export const createContainerResponse = zod.object({
  "id": zod.string().describe('Unique identifier for the container.'),
  "object": zod.string().describe('The type of this object.'),
  "name": zod.string().describe('Name of the container.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the container was created.'),
  "status": zod.string().describe('Status of the container (e.g., active, deleted).'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).optional().describe('The reference point for the expiration.'),
  "minutes": zod.number().optional().describe('The number of minutes after the anchor before the container expires.')
}).optional().describe('The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n')
})

/**
 * Retrieve Container
 * @summary Retrieve container
 */
export const retrieveContainerParams = zod.object({
  "container_id": zod.string()
})

export const retrieveContainerResponse = zod.object({
  "id": zod.string().describe('Unique identifier for the container.'),
  "object": zod.string().describe('The type of this object.'),
  "name": zod.string().describe('Name of the container.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the container was created.'),
  "status": zod.string().describe('Status of the container (e.g., active, deleted).'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).optional().describe('The reference point for the expiration.'),
  "minutes": zod.number().optional().describe('The number of minutes after the anchor before the container expires.')
}).optional().describe('The container will expire after this time period.\nThe anchor is the reference point for the expiration.\nThe minutes is the number of minutes after the anchor before the container expires.\n')
})

/**
 * Delete Container
 * @summary Delete a container
 */
export const deleteContainerParams = zod.object({
  "container_id": zod.string().describe('The ID of the container to delete.')
})

/**
 * Create a Container File

You can send either a multipart/form-data request with the raw file content, or a JSON request with a file ID.

 * @summary Create container file
 */
export const createContainerFileParams = zod.object({
  "container_id": zod.string()
})

export const createContainerFileBody = zod.object({
  "file_id": zod.string().optional().describe('Name of the file to create.'),
  "file": zod.instanceof(File).optional().describe('The File object (not file name) to be uploaded.\n')
})

export const createContainerFileResponse = zod.object({
  "id": zod.string().describe('Unique identifier for the file.'),
  "object": zod.string().describe('The type of this object (`container.file`).'),
  "container_id": zod.string().describe('The container this file belongs to.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the file was created.'),
  "bytes": zod.number().describe('Size of the file in bytes.'),
  "path": zod.string().describe('Path of the file in the container.'),
  "source": zod.string().describe('Source of the file (e.g., `user`, `assistant`).')
})

/**
 * List Container files
 * @summary List container files
 */
export const listContainerFilesParams = zod.object({
  "container_id": zod.string()
})

export const listContainerFilesQueryLimitDefault = 20;export const listContainerFilesQueryOrderDefault = "desc";

export const listContainerFilesQueryParams = zod.object({
  "limit": zod.number().optional().describe('A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n'),
  "after": zod.string().optional().describe('A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n')
})

export const listContainerFilesResponse = zod.object({
  "object": zod.any().describe('The type of object returned, must be \'list\'.'),
  "data": zod.array(zod.object({
  "id": zod.string().describe('Unique identifier for the file.'),
  "object": zod.string().describe('The type of this object (`container.file`).'),
  "container_id": zod.string().describe('The container this file belongs to.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the file was created.'),
  "bytes": zod.number().describe('Size of the file in bytes.'),
  "path": zod.string().describe('Path of the file in the container.'),
  "source": zod.string().describe('Source of the file (e.g., `user`, `assistant`).')
})).describe('A list of container files.'),
  "first_id": zod.string().describe('The ID of the first file in the list.'),
  "last_id": zod.string().describe('The ID of the last file in the list.'),
  "has_more": zod.boolean().describe('Whether there are more files available.')
})

/**
 * Retrieve Container File
 * @summary Retrieve container file
 */
export const retrieveContainerFileParams = zod.object({
  "container_id": zod.string(),
  "file_id": zod.string()
})

export const retrieveContainerFileResponse = zod.object({
  "id": zod.string().describe('Unique identifier for the file.'),
  "object": zod.string().describe('The type of this object (`container.file`).'),
  "container_id": zod.string().describe('The container this file belongs to.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) when the file was created.'),
  "bytes": zod.number().describe('Size of the file in bytes.'),
  "path": zod.string().describe('Path of the file in the container.'),
  "source": zod.string().describe('Source of the file (e.g., `user`, `assistant`).')
})

/**
 * Delete Container File
 * @summary Delete a container file
 */
export const deleteContainerFileParams = zod.object({
  "container_id": zod.string(),
  "file_id": zod.string()
})

/**
 * Retrieve Container File Content
 * @summary Retrieve container file content
 */
export const retrieveContainerFileContentParams = zod.object({
  "container_id": zod.string(),
  "file_id": zod.string()
})

/**
 * List organization API keys
 * @summary List all organization and project API keys.
 */
export const adminApiKeysListQueryOrderDefault = "asc";export const adminApiKeysListQueryLimitDefault = 20;

export const adminApiKeysListQueryParams = zod.object({
  "after": zod.string().nullish(),
  "order": zod.enum(['asc', 'desc']).optional(),
  "limit": zod.number().optional()
})

export const adminApiKeysListResponse = zod.object({
  "object": zod.string().optional(),
  "data": zod.array(zod.object({
  "object": zod.string().describe('The object type, which is always `organization.admin_api_key`'),
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().describe('The name of the API key'),
  "redacted_value": zod.string().describe('The redacted value of the API key'),
  "value": zod.string().optional().describe('The value of the API key. Only shown on create.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was created'),
  "last_used_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was last used').or(zod.null()),
  "owner": zod.object({
  "type": zod.string().optional().describe('Always `user`'),
  "object": zod.string().optional().describe('The object type, which is always organization.user'),
  "id": zod.string().optional().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().optional().describe('The name of the user'),
  "created_at": zod.number().optional().describe('The Unix timestamp (in seconds) of when the user was created'),
  "role": zod.string().optional().describe('Always `owner`')
})
}).describe('Represents an individual Admin API key in an org.')).optional(),
  "has_more": zod.boolean().optional(),
  "first_id": zod.string().optional(),
  "last_id": zod.string().optional()
})

/**
 * Create an organization admin API key
 * @summary Create admin API key
 */
export const adminApiKeysCreateBody = zod.object({
  "name": zod.string()
})

export const adminApiKeysCreateResponse = zod.object({
  "object": zod.string().describe('The object type, which is always `organization.admin_api_key`'),
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().describe('The name of the API key'),
  "redacted_value": zod.string().describe('The redacted value of the API key'),
  "value": zod.string().optional().describe('The value of the API key. Only shown on create.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was created'),
  "last_used_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was last used').or(zod.null()),
  "owner": zod.object({
  "type": zod.string().optional().describe('Always `user`'),
  "object": zod.string().optional().describe('The object type, which is always organization.user'),
  "id": zod.string().optional().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().optional().describe('The name of the user'),
  "created_at": zod.number().optional().describe('The Unix timestamp (in seconds) of when the user was created'),
  "role": zod.string().optional().describe('Always `owner`')
})
}).describe('Represents an individual Admin API key in an org.')

/**
 * Retrieve a single organization API key
 * @summary Retrieve admin API key
 */
export const adminApiKeysGetParams = zod.object({
  "key_id": zod.string()
})

export const adminApiKeysGetResponse = zod.object({
  "object": zod.string().describe('The object type, which is always `organization.admin_api_key`'),
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().describe('The name of the API key'),
  "redacted_value": zod.string().describe('The redacted value of the API key'),
  "value": zod.string().optional().describe('The value of the API key. Only shown on create.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was created'),
  "last_used_at": zod.number().describe('The Unix timestamp (in seconds) of when the API key was last used').or(zod.null()),
  "owner": zod.object({
  "type": zod.string().optional().describe('Always `user`'),
  "object": zod.string().optional().describe('The object type, which is always organization.user'),
  "id": zod.string().optional().describe('The identifier, which can be referenced in API endpoints'),
  "name": zod.string().optional().describe('The name of the user'),
  "created_at": zod.number().optional().describe('The Unix timestamp (in seconds) of when the user was created'),
  "role": zod.string().optional().describe('Always `owner`')
})
}).describe('Represents an individual Admin API key in an org.')

/**
 * Delete an organization admin API key
 * @summary Delete admin API key
 */
export const adminApiKeysDeleteParams = zod.object({
  "key_id": zod.string()
})

export const adminApiKeysDeleteResponse = zod.object({
  "id": zod.string().optional(),
  "object": zod.string().optional(),
  "deleted": zod.boolean().optional()
})

/**
 * Get input token counts
 * @summary Get input token counts
 */
export const getinputtokencountsBodyInputMaxTwo = 10485760;
export const getinputtokencountsBodyInputItemContentItemTypeDefault = "input_text";export const getinputtokencountsBodyInputItemContentItemTypeDefaultOne = "input_image";export const getinputtokencountsBodyInputItemContentItemTypeDefaultTwo = "input_file";export const getinputtokencountsBodyInputItemContentItemTypeDefaultFour = "input_text";export const getinputtokencountsBodyInputItemContentItemTypeDefaultFive = "input_image";export const getinputtokencountsBodyInputItemContentItemTypeDefaultSix = "input_file";export const getinputtokencountsBodyInputItemContentItemTypeDefaultEight = "output_text";export const getinputtokencountsBodyInputItemContentItemAnnotationsItemTypeDefault = "file_citation";export const getinputtokencountsBodyInputItemContentItemAnnotationsItemTypeDefaultOne = "url_citation";export const getinputtokencountsBodyInputItemContentItemAnnotationsItemTypeDefaultTwo = "container_file_citation";export const getinputtokencountsBodyInputItemContentItemTypeDefaultNine = "refusal";export const getinputtokencountsBodyInputItemResultsItemAttributesMaxThree = 512;
export const getinputtokencountsBodyInputItemTypeDefaultFour = "computer_call";export const getinputtokencountsBodyInputItemActionTypeDefault = "click";export const getinputtokencountsBodyInputItemActionTypeDefaultOne = "double_click";export const getinputtokencountsBodyInputItemActionTypeDefaultTwo = "drag";export const getinputtokencountsBodyInputItemActionTypeDefaultThree = "keypress";export const getinputtokencountsBodyInputItemActionTypeDefaultFour = "move";export const getinputtokencountsBodyInputItemActionTypeDefaultFive = "screenshot";export const getinputtokencountsBodyInputItemActionTypeDefaultSix = "scroll";export const getinputtokencountsBodyInputItemActionTypeDefaultSeven = "type";export const getinputtokencountsBodyInputItemActionTypeDefaultEight = "wait";export const getinputtokencountsBodyInputItemCallIdMaxOne = 64;
export const getinputtokencountsBodyInputItemTypeDefaultFive = "computer_call_output";export const getinputtokencountsBodyInputItemOutputTypeDefault = "computer_screenshot";export const getinputtokencountsBodyInputItemCallIdMaxThree = 64;
export const getinputtokencountsBodyInputItemTypeDefaultEight = "function_call_output";export const getinputtokencountsBodyInputItemOutputMaxTwo = 10485760;
export const getinputtokencountsBodyInputItemOutputItemTypeDefault = "input_text";export const getinputtokencountsBodyInputItemOutputItemTextMax = 10485760;
export const getinputtokencountsBodyInputItemOutputItemTypeDefaultOne = "input_image";export const getinputtokencountsBodyInputItemOutputItemImageUrlMaxOne = 20971520;
export const getinputtokencountsBodyInputItemOutputItemTypeDefaultTwo = "input_file";export const getinputtokencountsBodyInputItemOutputItemFileDataMaxOne = 33554432;
export const getinputtokencountsBodyInputItemSummaryItemTypeDefault = "summary_text";export const getinputtokencountsBodyInputItemContentItemTypeDefaultOnezero = "reasoning_text";export const getinputtokencountsBodyInputItemTypeDefaultOneone = "code_interpreter_call";export const getinputtokencountsBodyInputItemOutputsItemTypeDefault = "logs";export const getinputtokencountsBodyInputItemOutputsItemTypeDefaultOne = "image";export const getinputtokencountsBodyInputItemActionTypeDefaultOnetwo = "exec";export const getinputtokencountsBodyInputItemOutputItemTypeDefaultThree = "input_text";export const getinputtokencountsBodyInputItemOutputItemTypeDefaultFour = "input_image";export const getinputtokencountsBodyInputItemOutputItemTypeDefaultFive = "input_file";export const getinputtokencountsBodyInputItemTypeDefaultTwoone = "item_reference";export const getinputtokencountsBodyToolsItemTypeDefault = "function";export const getinputtokencountsBodyToolsItemTypeDefaultOne = "file_search";export const getinputtokencountsBodyToolsItemFiltersTypeDefault = "eq";export const getinputtokencountsBodyToolsItemFiltersFiltersItemTypeDefault = "eq";export const getinputtokencountsBodyToolsItemTypeDefaultTwo = "computer_use_preview";export const getinputtokencountsBodyToolsItemTypeDefaultThree = "web_search";export const getinputtokencountsBodyToolsItemFiltersAllowedDomainsDefaultOne = [];export const getinputtokencountsBodyToolsItemUserLocationTypeDefault = "approximate";export const getinputtokencountsBodyToolsItemSearchContextSizeDefault = "medium";export const getinputtokencountsBodyToolsItemRequireApprovalDefaultOne = "always";export const getinputtokencountsBodyToolsItemContainerTypeDefault = "auto";export const getinputtokencountsBodyToolsItemContainerFileIdsMax = 50;
export const getinputtokencountsBodyToolsItemModelDefault = "gpt-image-1";export const getinputtokencountsBodyToolsItemQualityDefault = "auto";export const getinputtokencountsBodyToolsItemSizeDefault = "auto";export const getinputtokencountsBodyToolsItemOutputFormatDefault = "png";export const getinputtokencountsBodyToolsItemOutputCompressionDefault = 100;
export const getinputtokencountsBodyToolsItemOutputCompressionMin = 0;

export const getinputtokencountsBodyToolsItemOutputCompressionMax = 100;
export const getinputtokencountsBodyToolsItemModerationDefault = "auto";export const getinputtokencountsBodyToolsItemBackgroundDefault = "auto";export const getinputtokencountsBodyToolsItemPartialImagesDefault = 0;
export const getinputtokencountsBodyToolsItemPartialImagesMin = 0;

export const getinputtokencountsBodyToolsItemPartialImagesMax = 3;
export const getinputtokencountsBodyToolsItemTypeDefaultSeven = "local_shell";export const getinputtokencountsBodyToolsItemTypeDefaultEight = "custom";export const getinputtokencountsBodyToolsItemFormatTypeDefault = "text";export const getinputtokencountsBodyToolsItemFormatTypeDefaultOne = "grammar";export const getinputtokencountsBodyToolsItemTypeDefaultNine = "web_search_preview";export const getinputtokencountsBodyToolsItemUserLocationTypeDefaultOne = "approximate";export const getinputtokencountsBodyTextFormatStrictDefaultOne = false;export const getinputtokencountsBodyTextVerbosityDefaultOne = "medium";export const getinputtokencountsBodyReasoningEffortDefaultOne = "medium";

export const getinputtokencountsBody = zod.object({
  "model": zod.string().describe('Model ID used to generate the response, like `gpt-4o` or `o3`. OpenAI offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the [model guide](https://platform.openai.com/docs/models) to browse and compare available models.').or(zod.null()).optional(),
  "input": zod.string().max(getinputtokencountsBodyInputMaxTwo).describe('A text input to the model, equivalent to a text input with the `user` role.').or(zod.array(zod.discriminatedUnion('type', [zod.object({
  "role": zod.enum(['user', 'assistant', 'system', 'developer']).describe('The role of the message input. One of `user`, `assistant`, `system`, or\n`developer`.\n'),
  "content": zod.string().describe('A text input to the model.\n').or(zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['input_text']).optional().describe('The type of the input item. Always `input_text`.'),
  "text": zod.string().describe('The text input to the model.')
}).describe('A text input to the model.'),zod.object({
  "type": zod.enum(['input_image']).optional().describe('The type of the input item. Always `input_image`.'),
  "image_url": zod.string().describe('The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.').or(zod.null()).optional(),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "detail": zod.enum(['low', 'high', 'auto'])
}).describe('An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision).'),zod.object({
  "type": zod.enum(['input_file']).optional().describe('The type of the input item. Always `input_file`.'),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "filename": zod.string().optional().describe('The name of the file to be sent to the model.'),
  "file_url": zod.string().optional().describe('The URL of the file to be sent to the model.'),
  "file_data": zod.string().optional().describe('The content of the file to be sent to the model.\n')
}).describe('A file input to the model.'),zod.object({
  "type": zod.enum(['input_audio']).describe('The type of the input item. Always `input_audio`.\n'),
  "input_audio": zod.object({
  "data": zod.string().describe('Base64-encoded audio data.\n'),
  "format": zod.enum(['mp3', 'wav']).describe('The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n')
})
}).describe('An audio input to the model.\n')])).describe('A list of one or many input items to the model, containing different content\ntypes.\n')).describe('Text, image, or audio input to the model, used to generate a response.\nCan also contain previous assistant responses.\n'),
  "type": zod.enum(['message']).optional().describe('The type of the message input. Always `message`.\n')
}).describe('A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role. Messages with the\n`assistant` role are presumed to have been generated by the model in previous\ninteractions.\n'),zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['message']).optional().describe('The type of the message input. Always set to `message`.\n'),
  "role": zod.enum(['user', 'system', 'developer']).describe('The role of the message input. One of `user`, `system`, or `developer`.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).optional().describe('The status of item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n'),
  "content": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['input_text']).optional().describe('The type of the input item. Always `input_text`.'),
  "text": zod.string().describe('The text input to the model.')
}).describe('A text input to the model.'),zod.object({
  "type": zod.enum(['input_image']).optional().describe('The type of the input item. Always `input_image`.'),
  "image_url": zod.string().describe('The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.').or(zod.null()).optional(),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "detail": zod.enum(['low', 'high', 'auto'])
}).describe('An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision).'),zod.object({
  "type": zod.enum(['input_file']).optional().describe('The type of the input item. Always `input_file`.'),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "filename": zod.string().optional().describe('The name of the file to be sent to the model.'),
  "file_url": zod.string().optional().describe('The URL of the file to be sent to the model.'),
  "file_data": zod.string().optional().describe('The content of the file to be sent to the model.\n')
}).describe('A file input to the model.'),zod.object({
  "type": zod.enum(['input_audio']).describe('The type of the input item. Always `input_audio`.\n'),
  "input_audio": zod.object({
  "data": zod.string().describe('Base64-encoded audio data.\n'),
  "format": zod.enum(['mp3', 'wav']).describe('The format of the audio data. Currently supported formats are `mp3` and\n`wav`.\n')
})
}).describe('An audio input to the model.\n')])).describe('A list of one or many input items to the model, containing different content\ntypes.\n')
}).describe('A message input to the model with a role indicating instruction following\nhierarchy. Instructions given with the `developer` or `system` role take\nprecedence over instructions given with the `user` role.\n'),zod.object({
  "id": zod.string().describe('The unique ID of the output message.\n'),
  "type": zod.enum(['message']).describe('The type of the output message. Always `message`.\n'),
  "role": zod.enum(['assistant']).describe('The role of the output message. Always `assistant`.\n'),
  "content": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['output_text']).optional().describe('The type of the output text. Always `output_text`.'),
  "text": zod.string().describe('The text output from the model.'),
  "annotations": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['file_citation']).optional().describe('The type of the file citation. Always `file_citation`.'),
  "file_id": zod.string().describe('The ID of the file.'),
  "index": zod.number().describe('The index of the file in the list of files.'),
  "filename": zod.string().describe('The filename of the file cited.')
}).describe('A citation to a file.'),zod.object({
  "type": zod.enum(['url_citation']).optional().describe('The type of the URL citation. Always `url_citation`.'),
  "url": zod.string().describe('The URL of the web resource.'),
  "start_index": zod.number().describe('The index of the first character of the URL citation in the message.'),
  "end_index": zod.number().describe('The index of the last character of the URL citation in the message.'),
  "title": zod.string().describe('The title of the web resource.')
}).describe('A citation for a web resource used to generate a model response.'),zod.object({
  "type": zod.enum(['container_file_citation']).optional().describe('The type of the container file citation. Always `container_file_citation`.'),
  "container_id": zod.string().describe('The ID of the container file.'),
  "file_id": zod.string().describe('The ID of the file.'),
  "start_index": zod.number().describe('The index of the first character of the container file citation in the message.'),
  "end_index": zod.number().describe('The index of the last character of the container file citation in the message.'),
  "filename": zod.string().describe('The filename of the container file cited.')
}).describe('A citation for a container file used to generate a model response.'),zod.object({
  "type": zod.enum(['file_path']).describe('The type of the file path. Always `file_path`.\n'),
  "file_id": zod.string().describe('The ID of the file.\n'),
  "index": zod.number().describe('The index of the file in the list of files.\n')
}).describe('A path to a file.\n')])).describe('The annotations of the text output.'),
  "logprobs": zod.array(zod.object({
  "token": zod.string(),
  "logprob": zod.number(),
  "bytes": zod.array(zod.number()),
  "top_logprobs": zod.array(zod.object({
  "token": zod.string(),
  "logprob": zod.number(),
  "bytes": zod.array(zod.number())
}).describe('The top log probability of a token.'))
}).describe('The log probability of a token.')).optional()
}).describe('A text output from the model.'),zod.object({
  "type": zod.enum(['refusal']).optional().describe('The type of the refusal. Always `refusal`.'),
  "refusal": zod.string().describe('The refusal explanation from the model.')
}).describe('A refusal from the model.')])).describe('The content of the output message.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).describe('The status of the message input. One of `in_progress`, `completed`, or\n`incomplete`. Populated when input items are returned via API.\n')
}).describe('An output message from the model.\n'),zod.object({
  "id": zod.string().describe('The unique ID of the file search tool call.\n'),
  "type": zod.enum(['file_search_call']).describe('The type of the file search tool call. Always `file_search_call`.\n'),
  "status": zod.enum(['in_progress', 'searching', 'completed', 'incomplete', 'failed']).describe('The status of the file search tool call. One of `in_progress`,\n`searching`, `incomplete` or `failed`,\n'),
  "queries": zod.array(zod.string()).describe('The queries used to search for files.\n'),
  "results": zod.array(zod.object({
  "file_id": zod.string().optional().describe('The unique ID of the file.\n'),
  "text": zod.string().optional().describe('The text that was retrieved from the file.\n'),
  "filename": zod.string().optional().describe('The name of the file.\n'),
  "attributes": zod.record(zod.string(), zod.string().max(getinputtokencountsBodyInputItemResultsItemAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional(),
  "score": zod.number().optional().describe('The relevance score of the file - a value between 0 and 1.\n')
})).describe('The results of the file search tool call.\n').or(zod.null()).optional()
}).describe('The results of a file search tool call. See the\n[file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.\n'),zod.object({
  "type": zod.enum(['computer_call']).optional().describe('The type of the computer call. Always `computer_call`.'),
  "id": zod.string().describe('The unique ID of the computer call.'),
  "call_id": zod.string().describe('An identifier used when responding to the tool call with output.\n'),
  "action": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['click']).optional().describe('Specifies the event type. For a click action, this property is always `click`.'),
  "button": zod.enum(['left', 'right', 'wheel', 'back', 'forward']),
  "x": zod.number().describe('The x-coordinate where the click occurred.'),
  "y": zod.number().describe('The y-coordinate where the click occurred.')
}).describe('A click action.'),zod.object({
  "type": zod.enum(['double_click']).optional().describe('Specifies the event type. For a double click action, this property is always set to `double_click`.'),
  "x": zod.number().describe('The x-coordinate where the double click occurred.'),
  "y": zod.number().describe('The y-coordinate where the double click occurred.')
}).describe('A double click action.'),zod.object({
  "type": zod.enum(['drag']).optional().describe('Specifies the event type. For a drag action, this property is\nalways set to `drag`.\n'),
  "path": zod.array(zod.object({
  "x": zod.number().describe('The x-coordinate.'),
  "y": zod.number().describe('The y-coordinate.')
}).describe('An x/y coordinate pair, e.g. `{ x: 100, y: 200 }`.')).describe('An array of coordinates representing the path of the drag action. Coordinates will appear as an array\nof objects, eg\n```\n[\n  { x: 100, y: 200 },\n  { x: 200, y: 300 }\n]\n```\n')
}).describe('A drag action.\n'),zod.object({
  "type": zod.enum(['keypress']).optional().describe('Specifies the event type. For a keypress action, this property is always set to `keypress`.'),
  "keys": zod.array(zod.string().describe('One of the keys the model is requesting to be pressed.')).describe('The combination of keys the model is requesting to be pressed. This is an array of strings, each representing a key.')
}).describe('A collection of keypresses the model would like to perform.'),zod.object({
  "type": zod.enum(['move']).optional().describe('Specifies the event type. For a move action, this property is\nalways set to `move`.\n'),
  "x": zod.number().describe('The x-coordinate to move to.\n'),
  "y": zod.number().describe('The y-coordinate to move to.\n')
}).describe('A mouse move action.\n'),zod.object({
  "type": zod.enum(['screenshot']).optional().describe('Specifies the event type. For a screenshot action, this property is\nalways set to `screenshot`.\n')
}).describe('A screenshot action.\n'),zod.object({
  "type": zod.enum(['scroll']).optional().describe('Specifies the event type. For a scroll action, this property is\nalways set to `scroll`.\n'),
  "x": zod.number().describe('The x-coordinate where the scroll occurred.\n'),
  "y": zod.number().describe('The y-coordinate where the scroll occurred.\n'),
  "scroll_x": zod.number().describe('The horizontal scroll distance.\n'),
  "scroll_y": zod.number().describe('The vertical scroll distance.\n')
}).describe('A scroll action.\n'),zod.object({
  "type": zod.enum(['type']).optional().describe('Specifies the event type. For a type action, this property is\nalways set to `type`.\n'),
  "text": zod.string().describe('The text to type.\n')
}).describe('An action to type in text.\n'),zod.object({
  "type": zod.enum(['wait']).optional().describe('Specifies the event type. For a wait action, this property is\nalways set to `wait`.\n')
}).describe('A wait action.\n')]),
  "pending_safety_checks": zod.array(zod.object({
  "id": zod.string().describe('The ID of the pending safety check.'),
  "code": zod.string().describe('The type of the pending safety check.').or(zod.null()).optional(),
  "message": zod.string().describe('Details about the pending safety check.').or(zod.null()).optional()
}).describe('A pending safety check for the computer call.')).describe('The pending safety checks for the computer call.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).describe('The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n')
}).describe('A tool call to a computer use tool. See the\n[computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.\n'),zod.object({
  "id": zod.string().describe('The ID of the computer tool call output.').or(zod.null()).optional(),
  "call_id": zod.string().min(1).max(getinputtokencountsBodyInputItemCallIdMaxOne).describe('The ID of the computer tool call that produced the output.'),
  "type": zod.enum(['computer_call_output']).optional().describe('The type of the computer tool call output. Always `computer_call_output`.'),
  "output": zod.object({
  "type": zod.enum(['computer_screenshot']).optional().describe('Specifies the event type. For a computer screenshot, this property is\nalways set to `computer_screenshot`.\n'),
  "image_url": zod.string().optional().describe('The URL of the screenshot image.'),
  "file_id": zod.string().optional().describe('The identifier of an uploaded file that contains the screenshot.')
}).describe('A computer screenshot image used with the computer use tool.\n'),
  "acknowledged_safety_checks": zod.array(zod.object({
  "id": zod.string().describe('The ID of the pending safety check.'),
  "code": zod.string().describe('The type of the pending safety check.').or(zod.null()).optional(),
  "message": zod.string().describe('Details about the pending safety check.').or(zod.null()).optional()
}).describe('A pending safety check for the computer call.')).describe('The safety checks reported by the API that have been acknowledged by the developer.').or(zod.null()).optional(),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).or(zod.null()).optional()
}).describe('The output of a computer tool call.'),zod.object({
  "id": zod.string().describe('The unique ID of the web search tool call.\n'),
  "type": zod.enum(['web_search_call']).describe('The type of the web search tool call. Always `web_search_call`.\n'),
  "status": zod.enum(['in_progress', 'searching', 'completed', 'failed']).describe('The status of the web search tool call.\n'),
  "action": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['search']).describe('The action type.\n'),
  "query": zod.string().describe('The search query.\n'),
  "sources": zod.array(zod.object({
  "type": zod.enum(['url']).describe('The type of source. Always `url`.\n'),
  "url": zod.string().describe('The URL of the source.\n')
}).describe('A source used in the search.\n')).optional().describe('The sources used in the search.\n')
}).describe('Action type \"search\" - Performs a web search query.\n'),zod.object({
  "type": zod.enum(['open_page']).describe('The action type.\n'),
  "url": zod.string().url().describe('The URL opened by the model.\n')
}).describe('Action type \"open_page\" - Opens a specific URL from search results.\n'),zod.object({
  "type": zod.enum(['find']).describe('The action type.\n'),
  "url": zod.string().url().describe('The URL of the page searched for the pattern.\n'),
  "pattern": zod.string().describe('The pattern or text to search for within the page.\n')
}).describe('Action type \"find\": Searches for a pattern within a loaded page.\n')]).describe('An object describing the specific action taken in this web search call.\nIncludes details on how the model used the web (search, open_page, find).\n')
}).describe('The results of a web search tool call. See the\n[web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.\n'),zod.object({
  "id": zod.string().optional().describe('The unique ID of the function tool call.\n'),
  "type": zod.enum(['function_call']).describe('The type of the function tool call. Always `function_call`.\n'),
  "call_id": zod.string().describe('The unique ID of the function tool call generated by the model.\n'),
  "name": zod.string().describe('The name of the function to run.\n'),
  "arguments": zod.string().describe('A JSON string of the arguments to pass to the function.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).optional().describe('The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n')
}).describe('A tool call to run a function. See the\n[function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.\n'),zod.object({
  "id": zod.string().describe('The unique ID of the function tool call output. Populated when this item is returned via API.').or(zod.null()).optional(),
  "call_id": zod.string().min(1).max(getinputtokencountsBodyInputItemCallIdMaxThree).describe('The unique ID of the function tool call generated by the model.'),
  "type": zod.enum(['function_call_output']).optional().describe('The type of the function tool call output. Always `function_call_output`.'),
  "output": zod.string().max(getinputtokencountsBodyInputItemOutputMaxTwo).describe('A JSON string of the output of the function tool call.').or(zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['input_text']).optional().describe('The type of the input item. Always `input_text`.'),
  "text": zod.string().max(getinputtokencountsBodyInputItemOutputItemTextMax).describe('The text input to the model.')
}).describe('A text input to the model.'),zod.object({
  "type": zod.enum(['input_image']).optional().describe('The type of the input item. Always `input_image`.'),
  "image_url": zod.string().max(getinputtokencountsBodyInputItemOutputItemImageUrlMaxOne).describe('The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.').or(zod.null()).optional(),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "detail": zod.enum(['low', 'high', 'auto']).or(zod.null()).optional()
}).describe('An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision)'),zod.object({
  "type": zod.enum(['input_file']).optional().describe('The type of the input item. Always `input_file`.'),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "filename": zod.string().describe('The name of the file to be sent to the model.').or(zod.null()).optional(),
  "file_data": zod.string().max(getinputtokencountsBodyInputItemOutputItemFileDataMaxOne).describe('The base64-encoded data of the file to be sent to the model.').or(zod.null()).optional(),
  "file_url": zod.string().describe('The URL of the file to be sent to the model.').or(zod.null()).optional()
}).describe('A file input to the model.')]))).describe('Text, image, or file output of the function tool call.'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).or(zod.null()).optional()
}).describe('The output of a function tool call.'),zod.object({
  "type": zod.enum(['reasoning']).describe('The type of the object. Always `reasoning`.\n'),
  "id": zod.string().describe('The unique identifier of the reasoning content.\n'),
  "encrypted_content": zod.string().describe('The encrypted content of the reasoning item - populated when a response is\ngenerated with `reasoning.encrypted_content` in the `include` parameter.\n').or(zod.null()).optional(),
  "summary": zod.array(zod.object({
  "type": zod.enum(['summary_text']).optional().describe('The type of the object. Always `summary_text`.'),
  "text": zod.string().describe('A summary of the reasoning output from the model so far.')
}).describe('A summary text from the model.')).describe('Reasoning summary content.\n'),
  "content": zod.array(zod.object({
  "type": zod.enum(['reasoning_text']).optional().describe('The type of the reasoning text. Always `reasoning_text`.'),
  "text": zod.string().describe('The reasoning text from the model.')
}).describe('Reasoning text from the model.')).optional().describe('Reasoning text content.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).optional().describe('The status of the item. One of `in_progress`, `completed`, or\n`incomplete`. Populated when items are returned via API.\n')
}).describe('A description of the chain of thought used by a reasoning model while generating\na response. Be sure to include these items in your `input` to the Responses API\nfor subsequent turns of a conversation if you are manually\n[managing context](https://platform.openai.com/docs/guides/conversation-state).\n'),zod.object({
  "type": zod.enum(['image_generation_call']).describe('The type of the image generation call. Always `image_generation_call`.\n'),
  "id": zod.string().describe('The unique ID of the image generation call.\n'),
  "status": zod.enum(['in_progress', 'completed', 'generating', 'failed']).describe('The status of the image generation call.\n'),
  "result": zod.string().describe('The generated image encoded in base64.\n').or(zod.null())
}).describe('An image generation request made by the model.\n'),zod.object({
  "type": zod.enum(['code_interpreter_call']).optional().describe('The type of the code interpreter tool call. Always `code_interpreter_call`.\n'),
  "id": zod.string().describe('The unique ID of the code interpreter tool call.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete', 'interpreting', 'failed']).describe('The status of the code interpreter tool call. Valid values are `in_progress`, `completed`, `incomplete`, `interpreting`, and `failed`.\n'),
  "container_id": zod.string().describe('The ID of the container used to run the code.\n'),
  "code": zod.string().describe('The code to run, or null if not available.\n').or(zod.null()),
  "outputs": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['logs']).optional().describe('The type of the output. Always `logs`.'),
  "logs": zod.string().describe('The logs output from the code interpreter.')
}).describe('The logs output from the code interpreter.'),zod.object({
  "type": zod.enum(['image']).optional().describe('The type of the output. Always `image`.'),
  "url": zod.string().describe('The URL of the image output from the code interpreter.')
}).describe('The image output from the code interpreter.')])).describe('The outputs generated by the code interpreter, such as logs or images.\nCan be null if no outputs are available.\n').or(zod.null())
}).describe('A tool call to run code.\n'),zod.object({
  "type": zod.enum(['local_shell_call']).describe('The type of the local shell call. Always `local_shell_call`.\n'),
  "id": zod.string().describe('The unique ID of the local shell call.\n'),
  "call_id": zod.string().describe('The unique ID of the local shell tool call generated by the model.\n'),
  "action": zod.object({
  "type": zod.enum(['exec']).optional().describe('The type of the local shell action. Always `exec`.'),
  "command": zod.array(zod.string()).describe('The command to run.'),
  "timeout_ms": zod.number().describe('Optional timeout in milliseconds for the command.').or(zod.null()).optional(),
  "working_directory": zod.string().describe('Optional working directory to run the command in.').or(zod.null()).optional(),
  "env": zod.record(zod.string(), zod.string()).describe('Environment variables to set for the command.'),
  "user": zod.string().describe('Optional user to run the command as.').or(zod.null()).optional()
}).describe('Execute a shell command on the server.'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).describe('The status of the local shell call.\n')
}).describe('A tool call to run a command on the local shell.\n'),zod.object({
  "type": zod.enum(['local_shell_call_output']).describe('The type of the local shell tool call output. Always `local_shell_call_output`.\n'),
  "id": zod.string().describe('The unique ID of the local shell tool call generated by the model.\n'),
  "output": zod.string().describe('A JSON string of the output of the local shell tool call.\n'),
  "status": zod.enum(['in_progress', 'completed', 'incomplete']).describe('The status of the item. One of `in_progress`, `completed`, or `incomplete`.\n').or(zod.null()).optional()
}).describe('The output of a local shell tool call.\n'),zod.object({
  "type": zod.enum(['mcp_list_tools']).describe('The type of the item. Always `mcp_list_tools`.\n'),
  "id": zod.string().describe('The unique ID of the list.\n'),
  "server_label": zod.string().describe('The label of the MCP server.\n'),
  "tools": zod.array(zod.object({
  "name": zod.string().describe('The name of the tool.\n'),
  "description": zod.string().describe('The description of the tool.\n').or(zod.null()).optional(),
  "input_schema": zod.object({

}).describe('The JSON schema describing the tool\'s input.\n'),
  "annotations": zod.object({

}).describe('Additional annotations about the tool.\n').or(zod.null()).optional()
}).describe('A tool available on an MCP server.\n')).describe('The tools available on the server.\n'),
  "error": zod.string().describe('Error message if the server could not list tools.\n').or(zod.null()).optional()
}).describe('A list of tools available on an MCP server.\n'),zod.object({
  "type": zod.enum(['mcp_approval_request']).describe('The type of the item. Always `mcp_approval_request`.\n'),
  "id": zod.string().describe('The unique ID of the approval request.\n'),
  "server_label": zod.string().describe('The label of the MCP server making the request.\n'),
  "name": zod.string().describe('The name of the tool to run.\n'),
  "arguments": zod.string().describe('A JSON string of arguments for the tool.\n')
}).describe('A request for human approval of a tool invocation.\n'),zod.object({
  "type": zod.enum(['mcp_approval_response']).describe('The type of the item. Always `mcp_approval_response`.\n'),
  "id": zod.string().describe('The unique ID of the approval response\n').or(zod.null()).optional(),
  "approval_request_id": zod.string().describe('The ID of the approval request being answered.\n'),
  "approve": zod.boolean().describe('Whether the request was approved.\n'),
  "reason": zod.string().describe('Optional reason for the decision.\n').or(zod.null()).optional()
}).describe('A response to an MCP approval request.\n'),zod.object({
  "type": zod.enum(['mcp_call']).describe('The type of the item. Always `mcp_call`.\n'),
  "id": zod.string().describe('The unique ID of the tool call.\n'),
  "server_label": zod.string().describe('The label of the MCP server running the tool.\n'),
  "name": zod.string().describe('The name of the tool that was run.\n'),
  "arguments": zod.string().describe('A JSON string of the arguments passed to the tool.\n'),
  "output": zod.string().describe('The output from the tool call.\n').or(zod.null()).optional(),
  "error": zod.string().describe('The error from the tool call, if any.\n').or(zod.null()).optional(),
  "status": zod.enum(['in_progress', 'completed', 'incomplete', 'calling', 'failed']).optional(),
  "approval_request_id": zod.string().describe('Unique identifier for the MCP tool call approval request.\nInclude this value in a subsequent `mcp_approval_response` input to approve or reject the corresponding tool call.\n').or(zod.null()).optional()
}).describe('An invocation of a tool on an MCP server.\n'),zod.object({
  "type": zod.enum(['custom_tool_call_output']).describe('The type of the custom tool call output. Always `custom_tool_call_output`.\n'),
  "id": zod.string().optional().describe('The unique ID of the custom tool call output in the OpenAI platform.\n'),
  "call_id": zod.string().describe('The call ID, used to map this custom tool call output to a custom tool call.\n'),
  "output": zod.string().describe('A string of the output of the custom tool call.\n').or(zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['input_text']).optional().describe('The type of the input item. Always `input_text`.'),
  "text": zod.string().describe('The text input to the model.')
}).describe('A text input to the model.'),zod.object({
  "type": zod.enum(['input_image']).optional().describe('The type of the input item. Always `input_image`.'),
  "image_url": zod.string().describe('The URL of the image to be sent to the model. A fully qualified URL or base64 encoded image in a data URL.').or(zod.null()).optional(),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "detail": zod.enum(['low', 'high', 'auto'])
}).describe('An image input to the model. Learn about [image inputs](https://platform.openai.com/docs/guides/vision).'),zod.object({
  "type": zod.enum(['input_file']).optional().describe('The type of the input item. Always `input_file`.'),
  "file_id": zod.string().describe('The ID of the file to be sent to the model.').or(zod.null()).optional(),
  "filename": zod.string().optional().describe('The name of the file to be sent to the model.'),
  "file_url": zod.string().optional().describe('The URL of the file to be sent to the model.'),
  "file_data": zod.string().optional().describe('The content of the file to be sent to the model.\n')
}).describe('A file input to the model.')])).describe('Text, image, or file output of the custom tool call.\n')).describe('The output from the custom tool call generated by your code.\nCan be a string or an list of output content.\n')
}).describe('The output of a custom tool call from your code, being sent back to the model.\n'),zod.object({
  "type": zod.enum(['custom_tool_call']).describe('The type of the custom tool call. Always `custom_tool_call`.\n'),
  "id": zod.string().optional().describe('The unique ID of the custom tool call in the OpenAI platform.\n'),
  "call_id": zod.string().describe('An identifier used to map this custom tool call to a tool call output.\n'),
  "name": zod.string().describe('The name of the custom tool being called.\n'),
  "input": zod.string().describe('The input for the custom tool call generated by the model.\n')
}).describe('A call to a custom tool created by the model.\n')]).describe('Content item used to generate a response.\n'),zod.object({
  "type": zod.enum(['item_reference']).optional().describe('The type of item to reference. Always `item_reference`.').or(zod.null()).optional(),
  "id": zod.string().describe('The ID of the item to reference.')
}).describe('An internal identifier for an item to reference.')]))).describe('Text, image, or file inputs to the model, used to generate a response').or(zod.null()).optional(),
  "previous_response_id": zod.string().describe('The unique ID of the previous response to the model. Use this to create multi-turn conversations. Learn more about [conversation state](https://platform.openai.com/docs/guides/conversation-state). Cannot be used in conjunction with `conversation`.').or(zod.null()).optional(),
  "tools": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['function']).optional().describe('The type of the function tool. Always `function`.'),
  "name": zod.string().describe('The name of the function to call.'),
  "description": zod.string().describe('A description of the function. Used by the model to determine whether or not to call the function.').or(zod.null()).optional(),
  "parameters": zod.record(zod.string(), zod.any()).describe('A JSON schema object describing the parameters of the function.').or(zod.null()),
  "strict": zod.boolean().describe('Whether to enforce strict parameter validation. Default `true`.').or(zod.null())
}).describe('Defines a function in your own code the model can choose to call. Learn more about [function calling](https://platform.openai.com/docs/guides/function-calling).'),zod.object({
  "type": zod.enum(['file_search']).optional().describe('The type of the file search tool. Always `file_search`.'),
  "vector_store_ids": zod.array(zod.string()).describe('The IDs of the vector stores to search.'),
  "max_num_results": zod.number().optional().describe('The maximum number of results to return. This number should be between 1 and 50 inclusive.'),
  "ranking_options": zod.object({
  "ranker": zod.enum(['auto', 'default-2024-11-15']).optional(),
  "score_threshold": zod.number().optional().describe('The score threshold for the file search, a number between 0 and 1. Numbers closer to 1 will attempt to return only the most relevant results, but may return fewer results.')
}).optional(),
  "filters": zod.object({
  "type": zod.enum(['eq', 'ne', 'gt', 'gte', 'lt', 'lte']).optional().describe('Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n'),
  "key": zod.string().describe('The key to compare against the value.'),
  "value": zod.string().or(zod.number()).or(zod.boolean()).or(zod.array(zod.string().or(zod.number()))).describe('The value to compare against the attribute key; supports string, number, or boolean types.')
}).describe('A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n').or(zod.object({
  "type": zod.enum(['and', 'or']).describe('Type of operation: `and` or `or`.'),
  "filters": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['eq', 'ne', 'gt', 'gte', 'lt', 'lte']).optional().describe('Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n'),
  "key": zod.string().describe('The key to compare against the value.'),
  "value": zod.string().or(zod.number()).or(zod.boolean()).or(zod.array(zod.string().or(zod.number()))).describe('The value to compare against the attribute key; supports string, number, or boolean types.')
}).describe('A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n'),.any()])).describe('Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`.')
}).describe('Combine multiple filters using `and` or `or`.')).or(zod.null()).optional()
}).describe('A tool that searches for relevant content from uploaded files. Learn more about the [file search tool](https://platform.openai.com/docs/guides/tools-file-search).'),zod.object({
  "type": zod.enum(['computer_use_preview']).optional().describe('The type of the computer use tool. Always `computer_use_preview`.'),
  "environment": zod.enum(['windows', 'mac', 'linux', 'ubuntu', 'browser']),
  "display_width": zod.number().describe('The width of the computer display.'),
  "display_height": zod.number().describe('The height of the computer display.')
}).describe('A tool that controls a virtual computer. Learn more about the [computer tool](https://platform.openai.com/docs/guides/tools-computer-use).'),zod.object({
  "type": zod.enum(['web_search', 'web_search_2025_08_26']).optional().describe('The type of the web search tool. One of `web_search` or `web_search_2025_08_26`.'),
  "filters": zod.object({
  "allowed_domains": zod.array(zod.string().describe('Allowed domain for the search.')).optional().describe('Allowed domains for the search. If not provided, all domains are allowed.\nSubdomains of the provided domains are allowed as well.\n\nExample: `[\"pubmed.ncbi.nlm.nih.gov\"]`\n').or(zod.null()).optional()
}).describe('Filters for the search.\n').or(zod.null()).optional(),
  "user_location": zod.object({
  "type": zod.enum(['approximate']).optional().describe('The type of location approximation. Always `approximate`.'),
  "country": zod.string().describe('The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`.').or(zod.null()).optional(),
  "region": zod.string().describe('Free text input for the region of the user, e.g. `California`.').or(zod.null()).optional(),
  "city": zod.string().describe('Free text input for the city of the user, e.g. `San Francisco`.').or(zod.null()).optional(),
  "timezone": zod.string().describe('The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`.').or(zod.null()).optional()
}).describe('The approximate location of the user.\n').or(zod.null()).optional(),
  "search_context_size": zod.enum(['low', 'medium', 'high']).optional().describe('High level guidance for the amount of context window space to use for the search. One of `low`, `medium`, or `high`. `medium` is the default.')
}).describe('Search the Internet for sources related to the prompt. Learn more about the\n[web search tool](https://platform.openai.com/docs/guides/tools-web-search).\n'),zod.object({
  "type": zod.enum(['mcp']).describe('The type of the MCP tool. Always `mcp`.'),
  "server_label": zod.string().describe('A label for this MCP server, used to identify it in tool calls.\n'),
  "server_url": zod.string().optional().describe('The URL for the MCP server. One of `server_url` or `connector_id` must be\nprovided.\n'),
  "connector_id": zod.enum(['connector_dropbox', 'connector_gmail', 'connector_googlecalendar', 'connector_googledrive', 'connector_microsoftteams', 'connector_outlookcalendar', 'connector_outlookemail', 'connector_sharepoint']).optional().describe('Identifier for service connectors, like those available in ChatGPT. One of\n`server_url` or `connector_id` must be provided. Learn more about service\nconnectors [here](https://platform.openai.com/docs/guides/tools-remote-mcp#connectors).\n\nCurrently supported `connector_id` values are:\n\n- Dropbox: `connector_dropbox`\n- Gmail: `connector_gmail`\n- Google Calendar: `connector_googlecalendar`\n- Google Drive: `connector_googledrive`\n- Microsoft Teams: `connector_microsoftteams`\n- Outlook Calendar: `connector_outlookcalendar`\n- Outlook Email: `connector_outlookemail`\n- SharePoint: `connector_sharepoint`\n'),
  "authorization": zod.string().optional().describe('An OAuth access token that can be used with a remote MCP server, either\nwith a custom MCP server URL or a service connector. Your application\nmust handle the OAuth authorization flow and provide the token here.\n'),
  "server_description": zod.string().optional().describe('Optional description of the MCP server, used to provide more context.\n'),
  "headers": zod.record(zod.string(), zod.string()).describe('Optional HTTP headers to send to the MCP server. Use for authentication\nor other purposes.\n').or(zod.null()).optional(),
  "allowed_tools": zod.array(zod.string()).describe('A string array of allowed tool names').or(zod.object({
  "tool_names": zod.array(zod.string()).optional().describe('List of allowed tool names.'),
  "read_only": zod.boolean().optional().describe('Indicates whether or not a tool modifies data or is read-only. If an\nMCP server is [annotated with `readOnlyHint`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\nit will match this filter.\n')
}).describe('A filter object to specify which tools are allowed.\n')).describe('List of allowed tool names or a filter object.\n').or(zod.null()).optional(),
  "require_approval": zod.object({
  "always": zod.object({
  "tool_names": zod.array(zod.string()).optional().describe('List of allowed tool names.'),
  "read_only": zod.boolean().optional().describe('Indicates whether or not a tool modifies data or is read-only. If an\nMCP server is [annotated with `readOnlyHint`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\nit will match this filter.\n')
}).optional().describe('A filter object to specify which tools are allowed.\n'),
  "never": zod.object({
  "tool_names": zod.array(zod.string()).optional().describe('List of allowed tool names.'),
  "read_only": zod.boolean().optional().describe('Indicates whether or not a tool modifies data or is read-only. If an\nMCP server is [annotated with `readOnlyHint`](https://modelcontextprotocol.io/specification/2025-06-18/schema#toolannotations-readonlyhint),\nit will match this filter.\n')
}).optional().describe('A filter object to specify which tools are allowed.\n')
}).describe('Specify which of the MCP server\'s tools require approval. Can be\n`always`, `never`, or a filter object associated with tools\nthat require approval.\n').or(zod.enum(['always', 'never']).describe('Specify a single approval policy for all tools. One of `always` or\n`never`. When set to `always`, all tools will require approval. When\nset to `never`, all tools will not require approval.\n')).optional().describe('Specify which of the MCP server\'s tools require approval.').or(zod.null()).optional()
}).describe('Give the model access to additional tools via remote Model Context Protocol\n(MCP) servers. [Learn more about MCP](https://platform.openai.com/docs/guides/tools-remote-mcp).\n'),zod.object({
  "type": zod.enum(['code_interpreter']).describe('The type of the code interpreter tool. Always `code_interpreter`.\n'),
  "container": zod.string().describe('The container ID.').or(zod.object({
  "type": zod.enum(['auto']).optional().describe('Always `auto`.'),
  "file_ids": zod.array(zod.string()).max(getinputtokencountsBodyToolsItemContainerFileIdsMax).optional().describe('An optional list of uploaded files to make available to your code.')
}).describe('Configuration for a code interpreter container. Optionally specify the IDs of the files to run the code on.')).describe('The code interpreter container. Can be a container ID or an object that\nspecifies uploaded file IDs to make available to your code.\n')
}).describe('A tool that runs Python code to help generate a response to a prompt.\n'),zod.object({
  "type": zod.enum(['image_generation']).describe('The type of the image generation tool. Always `image_generation`.\n'),
  "model": zod.enum(['gpt-image-1', 'gpt-image-1-mini']).optional().describe('The image generation model to use. Default: `gpt-image-1`.\n'),
  "quality": zod.enum(['low', 'medium', 'high', 'auto']).optional().describe('The quality of the generated image. One of `low`, `medium`, `high`,\nor `auto`. Default: `auto`.\n'),
  "size": zod.enum(['1024x1024', '1024x1536', '1536x1024', 'auto']).optional().describe('The size of the generated image. One of `1024x1024`, `1024x1536`,\n`1536x1024`, or `auto`. Default: `auto`.\n'),
  "output_format": zod.enum(['png', 'webp', 'jpeg']).optional().describe('The output format of the generated image. One of `png`, `webp`, or\n`jpeg`. Default: `png`.\n'),
  "output_compression": zod.number().min(getinputtokencountsBodyToolsItemOutputCompressionMin).max(getinputtokencountsBodyToolsItemOutputCompressionMax).optional().describe('Compression level for the output image. Default: 100.\n'),
  "moderation": zod.enum(['auto', 'low']).optional().describe('Moderation level for the generated image. Default: `auto`.\n'),
  "background": zod.enum(['transparent', 'opaque', 'auto']).optional().describe('Background type for the generated image. One of `transparent`,\n`opaque`, or `auto`. Default: `auto`.\n'),
  "input_fidelity": zod.enum(['high', 'low']).describe('\n            Control how much effort the model will exert to match the style and features, especially facial features, of input images. This parameter is only supported for `gpt-image-1`. Unsupported for `gpt-image-1-mini`. Supports `high` and `low`. Defaults to `low`.').or(zod.null()).optional(),
  "input_image_mask": zod.object({
  "image_url": zod.string().optional().describe('Base64-encoded mask image.\n'),
  "file_id": zod.string().optional().describe('File ID for the mask image.\n')
}).optional().describe('Optional mask for inpainting. Contains `image_url`\n(string, optional) and `file_id` (string, optional).\n'),
  "partial_images": zod.number().min(getinputtokencountsBodyToolsItemPartialImagesMin).max(getinputtokencountsBodyToolsItemPartialImagesMax).optional().describe('Number of partial images to generate in streaming mode, from 0 (default value) to 3.\n')
}).describe('A tool that generates images using a model like `gpt-image-1`.\n'),zod.object({
  "type": zod.enum(['local_shell']).optional().describe('The type of the local shell tool. Always `local_shell`.')
}),zod.object({
  "type": zod.enum(['custom']).optional().describe('The type of the custom tool. Always `custom`.'),
  "name": zod.string().describe('The name of the custom tool, used to identify it in tool calls.'),
  "description": zod.string().optional().describe('Optional description of the custom tool, used to provide more context.'),
  "format": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['text']).optional().describe('Unconstrained text format. Always `text`.')
}),zod.object({
  "type": zod.enum(['grammar']).optional().describe('Grammar format. Always `grammar`.'),
  "syntax": zod.enum(['lark', 'regex']),
  "definition": zod.string().describe('The grammar definition.')
})]).optional().describe('The input format for the custom tool. Default is unconstrained text.')
}),zod.object({
  "type": zod.enum(['web_search_preview', 'web_search_preview_2025_03_11']).optional().describe('The type of the web search tool. One of `web_search_preview` or `web_search_preview_2025_03_11`.'),
  "user_location": zod.object({
  "type": zod.enum(['approximate']).optional().describe('The type of location approximation. Always `approximate`.'),
  "country": zod.string().describe('The two-letter [ISO country code](https://en.wikipedia.org/wiki/ISO_3166-1) of the user, e.g. `US`.').or(zod.null()).optional(),
  "region": zod.string().describe('Free text input for the region of the user, e.g. `California`.').or(zod.null()).optional(),
  "city": zod.string().describe('Free text input for the city of the user, e.g. `San Francisco`.').or(zod.null()).optional(),
  "timezone": zod.string().describe('The [IANA timezone](https://timeapi.io/documentation/iana-timezones) of the user, e.g. `America/Los_Angeles`.').or(zod.null()).optional()
}).or(zod.null()).optional(),
  "search_context_size": zod.enum(['low', 'medium', 'high']).optional()
}).describe('This tool searches the web for relevant results to use in a response. Learn more about the [web search tool](https://platform.openai.com/docs/guides/tools-web-search).')]).describe('A tool that can be used to generate a response.\n')).describe('An array of tools the model may call while generating a response. You can specify which tool to use by setting the `tool_choice` parameter.').or(zod.null()).optional(),
  "text": zod.object({
  "format": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['text']).describe('The type of response format being defined. Always `text`.')
}).describe('Default response format. Used to generate text responses.\n'),zod.object({
  "type": zod.enum(['json_schema']).describe('The type of response format being defined. Always `json_schema`.'),
  "description": zod.string().optional().describe('A description of what the response format is for, used by the model to\ndetermine how to respond in the format.\n'),
  "name": zod.string().describe('The name of the response format. Must be a-z, A-Z, 0-9, or contain\nunderscores and dashes, with a maximum length of 64.\n'),
  "schema": zod.record(zod.string(), zod.any()).describe('The schema for the response format, described as a JSON Schema object.\nLearn how to build JSON schemas [here](https://json-schema.org/).\n'),
  "strict": zod.boolean().optional().describe('Whether to enable strict schema adherence when generating the output.\nIf set to true, the model will always follow the exact schema defined\nin the `schema` field. Only a subset of JSON Schema is supported when\n`strict` is `true`. To learn more, read the [Structured Outputs\nguide](https://platform.openai.com/docs/guides/structured-outputs).\n').or(zod.null()).optional()
}).describe('JSON Schema response format. Used to generate structured JSON responses.\nLearn more about [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs).\n'),zod.object({
  "type": zod.enum(['json_object']).describe('The type of response format being defined. Always `json_object`.')
}).describe('JSON object response format. An older method of generating JSON responses.\nUsing `json_schema` is recommended for models that support it. Note that the\nmodel will not generate JSON without a system or user message instructing it\nto do so.\n')]).optional().describe('An object specifying the format that the model must output.\n\nConfiguring `{ \"type\": \"json_schema\" }` enables Structured Outputs,\nwhich ensures the model will match your supplied JSON schema. Learn more in the\n[Structured Outputs guide](https://platform.openai.com/docs/guides/structured-outputs).\n\nThe default format is `{ \"type\": \"text\" }` with no additional options.\n\n**Not recommended for gpt-4o and newer models:**\n\nSetting to `{ \"type\": \"json_object\" }` enables the older JSON mode, which\nensures the message the model generates is valid JSON. Using `json_schema`\nis preferred for models that support it.\n'),
  "verbosity": zod.enum(['low', 'medium', 'high']).optional().describe('Constrains the verbosity of the model\'s response. Lower values will result in\nmore concise responses, while higher values will result in more verbose responses.\nCurrently supported values are `low`, `medium`, and `high`.\n').or(zod.null()).optional()
}).describe('Configuration options for a text response from the model. Can be plain\ntext or structured JSON data. Learn more:\n- [Text inputs and outputs](https://platform.openai.com/docs/guides/text)\n- [Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n').or(zod.null()).optional(),
  "reasoning": zod.object({
  "effort": zod.enum(['minimal', 'low', 'medium', 'high']).optional().describe('Constrains effort on reasoning for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\nCurrently supported values are `minimal`, `low`, `medium`, and `high`. Reducing\nreasoning effort can result in faster responses and fewer tokens used\non reasoning in a response.\n\nNote: The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.\n').or(zod.null()).optional(),
  "summary": zod.enum(['auto', 'concise', 'detailed']).describe('A summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model\'s reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n').or(zod.null()).optional(),
  "generate_summary": zod.enum(['auto', 'concise', 'detailed']).describe('**Deprecated:** use `summary` instead.\n\nA summary of the reasoning performed by the model. This can be\nuseful for debugging and understanding the model\'s reasoning process.\nOne of `auto`, `concise`, or `detailed`.\n').or(zod.null()).optional()
}).describe('**gpt-5 and o-series models only**\n\nConfiguration options for\n[reasoning models](https://platform.openai.com/docs/guides/reasoning).\n').or(zod.null()).optional(),
  "truncation": zod.enum(['auto', 'disabled']).optional(),
  "instructions": zod.string().describe('A system (or developer) message inserted into the model\'s context.\nWhen used along with `previous_response_id`, the instructions from a previous response will not be carried over to the next response. This makes it simple to swap out system (or developer) messages in new responses.').or(zod.null()).optional(),
  "conversation": zod.string().describe('The unique ID of the conversation.\n').or(zod.object({
  "id": zod.string().describe('The unique ID of the conversation.')
}).describe('The conversation that this response belongs to.')).describe('The conversation that this response belongs to. Items from this conversation are prepended to `input_items` for this response request.\nInput items and output items from this response are automatically added to this conversation after this response completes.\n').or(zod.null()).optional(),
  "tool_choice": zod.discriminatedUnion('type', [.enum(['none', 'auto', 'required']).describe('Controls which (if any) tool is called by the model.\n\n`none` means the model will not call any tool and instead generates a message.\n\n`auto` means the model can pick between generating a message or calling one or\nmore tools.\n\n`required` means the model must call one or more tools.\n'),zod.object({
  "type": zod.enum(['allowed_tools']).describe('Allowed tool configuration type. Always `allowed_tools`.'),
  "mode": zod.enum(['auto', 'required']).describe('Constrains the tools available to the model to a pre-defined set.\n\n`auto` allows the model to pick from among the allowed tools and generate a\nmessage.\n\n`required` requires the model to call one or more of the allowed tools.\n'),
  "tools": zod.array(zod.record(zod.string(), zod.any()).describe('A tool definition that the model should be allowed to call.\n')).describe('A list of tool definitions that the model should be allowed to call.\n\nFor the Responses API, the list of tool definitions might look like:\n```json\n[\n  { \"type\": \"function\", \"name\": \"get_weather\" },\n  { \"type\": \"mcp\", \"server_label\": \"deepwiki\" },\n  { \"type\": \"image_generation\" }\n]\n```\n')
}).describe('Constrains the tools available to the model to a pre-defined set.\n'),zod.object({
  "type": zod.enum(['file_search', 'web_search_preview', 'computer_use_preview', 'web_search_preview_2025_03_11', 'image_generation', 'code_interpreter']).describe('The type of hosted tool the model should to use. Learn more about\n[built-in tools](https://platform.openai.com/docs/guides/tools).\n\nAllowed values are:\n- `file_search`\n- `web_search_preview`\n- `computer_use_preview`\n- `code_interpreter`\n- `image_generation`\n')
}).describe('Indicates that the model should use a built-in tool to generate a response.\n[Learn more about built-in tools](https://platform.openai.com/docs/guides/tools).\n'),zod.object({
  "type": zod.enum(['function']).describe('For function calling, the type is always `function`.'),
  "name": zod.string().describe('The name of the function to call.')
}).describe('Use this option to force the model to call a specific function.\n'),zod.object({
  "type": zod.enum(['mcp']).describe('For MCP tools, the type is always `mcp`.'),
  "server_label": zod.string().describe('The label of the MCP server to use.\n'),
  "name": zod.string().describe('The name of the tool to call on the server.\n').or(zod.null()).optional()
}).describe('Use this option to force the model to call a specific tool on a remote MCP server.\n'),zod.object({
  "type": zod.enum(['custom']).describe('For custom tool calling, the type is always `custom`.'),
  "name": zod.string().describe('The name of the custom tool to call.')
}).describe('Use this option to force the model to call a specific custom tool.\n')]).describe('How the model should select which tool (or tools) to use when generating\na response. See the `tools` parameter to see how to specify which tools\nthe model can call.\n').or(zod.null()).optional(),
  "parallel_tool_calls": zod.boolean().describe('Whether to allow the model to run tool calls in parallel.').or(zod.null()).optional()
})

export const getinputtokencountsResponseObjectDefault = "response.input_tokens";

export const getinputtokencountsResponse = zod.object({
  "object": zod.enum(['response.input_tokens']).optional(),
  "input_tokens": zod.number()
})

/**
 * Cancel a ChatKit session
 * @summary Cancel chat session
 */
export const cancelChatSessionMethodParams = zod.object({
  "session_id": zod.string().describe('Unique identifier for the ChatKit session to cancel.')
})

export const cancelChatSessionMethodResponseObjectDefault = "chatkit.session";

export const cancelChatSessionMethodResponse = zod.object({
  "id": zod.string().describe('Identifier for the ChatKit session.'),
  "object": zod.enum(['chatkit.session']).optional().describe('Type discriminator that is always `chatkit.session`.'),
  "expires_at": zod.number().describe('Unix timestamp (in seconds) for when the session expires.'),
  "client_secret": zod.string().describe('Ephemeral client secret that authenticates session requests.'),
  "workflow": zod.object({
  "id": zod.string().describe('Identifier of the workflow backing the session.'),
  "version": zod.string().describe('Specific workflow version used for the session. Defaults to null when using the latest deployment.').or(zod.null()),
  "state_variables": zod.record(zod.string(), zod.string().or(zod.number()).or(zod.boolean()).or(zod.number())).describe('State variable key-value pairs applied when invoking the workflow. Defaults to null when no overrides were provided.').or(zod.null()),
  "tracing": zod.object({
  "enabled": zod.boolean().describe('Indicates whether tracing is enabled.')
}).describe('Controls diagnostic tracing during the session.')
}).describe('Workflow metadata and state returned for the session.'),
  "user": zod.string().describe('User identifier associated with the session.'),
  "rate_limits": zod.object({
  "max_requests_per_1_minute": zod.number().describe('Maximum allowed requests per one-minute window.')
}).describe('Active per-minute request limit for the session.'),
  "max_requests_per_1_minute": zod.number().describe('Convenience copy of the per-minute request limit.'),
  "status": zod.enum(['active', 'expired', 'cancelled']),
  "chatkit_configuration": zod.object({
  "automatic_thread_titling": zod.object({
  "enabled": zod.boolean().describe('Whether automatic thread titling is enabled.')
}).describe('Automatic thread title preferences for the session.'),
  "file_upload": zod.object({
  "enabled": zod.boolean().describe('Indicates if uploads are enabled for the session.'),
  "max_file_size": zod.number().describe('Maximum upload size in megabytes.').or(zod.null()),
  "max_files": zod.number().describe('Maximum number of uploads allowed during the session.').or(zod.null())
}).describe('Upload permissions and limits applied to the session.'),
  "history": zod.object({
  "enabled": zod.boolean().describe('Indicates if chat history is persisted for the session.'),
  "recent_threads": zod.number().describe('Number of prior threads surfaced in history views. Defaults to null when all history is retained.').or(zod.null())
}).describe('History retention preferences returned for the session.')
}).describe('ChatKit configuration for the session.')
}).describe('Represents a ChatKit session and its resolved configuration.')

/**
 * Create a ChatKit session
 * @summary Create ChatKit session
 */
export const createChatSessionMethodBodyWorkflowStateVariablesMaxTwo = 10485760;
export const createChatSessionMethodBodyExpiresAfterAnchorDefault = "created_at";export const createChatSessionMethodBodyExpiresAfterSecondsMax = 600;
export const createChatSessionMethodBodyChatkitConfigurationFileUploadMaxFileSizeMax = 512;


export const createChatSessionMethodBody = zod.object({
  "workflow": zod.object({
  "id": zod.string().describe('Identifier for the workflow invoked by the session.'),
  "version": zod.string().optional().describe('Specific workflow version to run. Defaults to the latest deployed version.'),
  "state_variables": zod.record(zod.string(), zod.string().max(createChatSessionMethodBodyWorkflowStateVariablesMaxTwo).or(zod.number()).or(zod.boolean()).or(zod.number())).optional().describe('State variables forwarded to the workflow. Keys may be up to 64 characters, values must be primitive types, and the map defaults to an empty object.'),
  "tracing": zod.object({
  "enabled": zod.boolean().optional().describe('Whether tracing is enabled during the session. Defaults to true.')
}).optional().describe('Controls diagnostic tracing during the session.')
}).describe('Workflow reference and overrides applied to the chat session.'),
  "user": zod.string().min(1).describe('A free-form string that identifies your end user; ensures this Session can access other objects that have the same `user` scope.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['created_at']).optional().describe('Base timestamp used to calculate expiration. Currently fixed to `created_at`.'),
  "seconds": zod.number().min(1).max(createChatSessionMethodBodyExpiresAfterSecondsMax).describe('Number of seconds after the anchor when the session expires.')
}).optional().describe('Controls when the session expires relative to an anchor timestamp.'),
  "rate_limits": zod.object({
  "max_requests_per_1_minute": zod.number().min(1).optional().describe('Maximum number of requests allowed per minute for the session. Defaults to 10.')
}).optional().describe('Controls request rate limits for the session.'),
  "chatkit_configuration": zod.object({
  "automatic_thread_titling": zod.object({
  "enabled": zod.boolean().optional().describe('Enable automatic thread title generation. Defaults to true.')
}).optional().describe('Controls whether ChatKit automatically generates thread titles.'),
  "file_upload": zod.object({
  "enabled": zod.boolean().optional().describe('Enable uploads for this session. Defaults to false.'),
  "max_file_size": zod.number().min(1).max(createChatSessionMethodBodyChatkitConfigurationFileUploadMaxFileSizeMax).optional().describe('Maximum size in megabytes for each uploaded file. Defaults to 512 MB, which is the maximum allowable size.'),
  "max_files": zod.number().min(1).optional().describe('Maximum number of files that can be uploaded to the session. Defaults to 10.')
}).optional().describe('Controls whether users can upload files.'),
  "history": zod.object({
  "enabled": zod.boolean().optional().describe('Enables chat users to access previous ChatKit threads. Defaults to true.'),
  "recent_threads": zod.number().min(1).optional().describe('Number of recent ChatKit threads users have access to. Defaults to unlimited when unset.')
}).optional().describe('Controls how much historical context is retained for the session.')
}).optional().describe('Optional per-session configuration settings for ChatKit behavior.')
}).describe('Parameters for provisioning a new ChatKit session.')

export const createChatSessionMethodResponseObjectDefault = "chatkit.session";

export const createChatSessionMethodResponse = zod.object({
  "id": zod.string().describe('Identifier for the ChatKit session.'),
  "object": zod.enum(['chatkit.session']).optional().describe('Type discriminator that is always `chatkit.session`.'),
  "expires_at": zod.number().describe('Unix timestamp (in seconds) for when the session expires.'),
  "client_secret": zod.string().describe('Ephemeral client secret that authenticates session requests.'),
  "workflow": zod.object({
  "id": zod.string().describe('Identifier of the workflow backing the session.'),
  "version": zod.string().describe('Specific workflow version used for the session. Defaults to null when using the latest deployment.').or(zod.null()),
  "state_variables": zod.record(zod.string(), zod.string().or(zod.number()).or(zod.boolean()).or(zod.number())).describe('State variable key-value pairs applied when invoking the workflow. Defaults to null when no overrides were provided.').or(zod.null()),
  "tracing": zod.object({
  "enabled": zod.boolean().describe('Indicates whether tracing is enabled.')
}).describe('Controls diagnostic tracing during the session.')
}).describe('Workflow metadata and state returned for the session.'),
  "user": zod.string().describe('User identifier associated with the session.'),
  "rate_limits": zod.object({
  "max_requests_per_1_minute": zod.number().describe('Maximum allowed requests per one-minute window.')
}).describe('Active per-minute request limit for the session.'),
  "max_requests_per_1_minute": zod.number().describe('Convenience copy of the per-minute request limit.'),
  "status": zod.enum(['active', 'expired', 'cancelled']),
  "chatkit_configuration": zod.object({
  "automatic_thread_titling": zod.object({
  "enabled": zod.boolean().describe('Whether automatic thread titling is enabled.')
}).describe('Automatic thread title preferences for the session.'),
  "file_upload": zod.object({
  "enabled": zod.boolean().describe('Indicates if uploads are enabled for the session.'),
  "max_file_size": zod.number().describe('Maximum upload size in megabytes.').or(zod.null()),
  "max_files": zod.number().describe('Maximum number of uploads allowed during the session.').or(zod.null())
}).describe('Upload permissions and limits applied to the session.'),
  "history": zod.object({
  "enabled": zod.boolean().describe('Indicates if chat history is persisted for the session.'),
  "recent_threads": zod.number().describe('Number of prior threads surfaced in history views. Defaults to null when all history is retained.').or(zod.null())
}).describe('History retention preferences returned for the session.')
}).describe('ChatKit configuration for the session.')
}).describe('Represents a ChatKit session and its resolved configuration.')

/**
 * List ChatKit thread items
 * @summary List ChatKit thread items
 */
export const listThreadItemsMethodParams = zod.object({
  "thread_id": zod.string().describe('Identifier of the ChatKit thread whose items are requested.')
})

export const listThreadItemsMethodQueryLimitMin = 0;

export const listThreadItemsMethodQueryLimitMax = 100;


export const listThreadItemsMethodQueryParams = zod.object({
  "limit": zod.number().min(listThreadItemsMethodQueryLimitMin).max(listThreadItemsMethodQueryLimitMax).optional().describe('Maximum number of thread items to return. Defaults to 20.'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order for results by creation time. Defaults to `desc`.'),
  "after": zod.string().optional().describe('List items created after this thread item ID. Defaults to null for the first page.'),
  "before": zod.string().optional().describe('List items created before this thread item ID. Defaults to null for the newest results.')
})

export const listThreadItemsMethodResponseObjectDefault = "list";export const listThreadItemsMethodResponseDataItemObjectDefault = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefault = "chatkit.user_message";export const listThreadItemsMethodResponseDataItemContentItemTypeDefault = "input_text";export const listThreadItemsMethodResponseDataItemContentItemTypeDefaultOne = "quoted_text";export const listThreadItemsMethodResponseDataItemObjectDefaultOne = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefaultOne = "chatkit.assistant_message";export const listThreadItemsMethodResponseDataItemContentItemTypeDefaultTwo = "output_text";export const listThreadItemsMethodResponseDataItemContentItemAnnotationsItemTypeDefault = "file";export const listThreadItemsMethodResponseDataItemContentItemAnnotationsItemSourceTypeDefault = "file";export const listThreadItemsMethodResponseDataItemContentItemAnnotationsItemTypeDefaultOne = "url";export const listThreadItemsMethodResponseDataItemContentItemAnnotationsItemSourceTypeDefaultOne = "url";export const listThreadItemsMethodResponseDataItemObjectDefaultTwo = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefaultTwo = "chatkit.widget";export const listThreadItemsMethodResponseDataItemObjectDefaultThree = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefaultThree = "chatkit.client_tool_call";export const listThreadItemsMethodResponseDataItemObjectDefaultFour = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefaultFour = "chatkit.task";export const listThreadItemsMethodResponseDataItemObjectDefaultFive = "chatkit.thread_item";export const listThreadItemsMethodResponseDataItemTypeDefaultFive = "chatkit.task_group";

export const listThreadItemsMethodResponse = zod.object({
  "object": zod.any().optional().describe('The type of object returned, must be `list`.'),
  "data": zod.array(zod.discriminatedUnion('type', [zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.user_message']).optional(),
  "content": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['input_text']).optional().describe('Type discriminator that is always `input_text`.'),
  "text": zod.string().describe('Plain-text content supplied by the user.')
}).describe('Text block that a user contributed to the thread.'),zod.object({
  "type": zod.enum(['quoted_text']).optional().describe('Type discriminator that is always `quoted_text`.'),
  "text": zod.string().describe('Quoted text content.')
}).describe('Quoted snippet that the user referenced in their message.')]).describe('Content blocks that comprise a user message.')).describe('Ordered content elements supplied by the user.'),
  "attachments": zod.array(zod.object({
  "type": zod.enum(['image', 'file']),
  "id": zod.string().describe('Identifier for the attachment.'),
  "name": zod.string().describe('Original display name for the attachment.'),
  "mime_type": zod.string().describe('MIME type of the attachment.'),
  "preview_url": zod.string().describe('Preview URL for rendering the attachment inline.').or(zod.null())
}).describe('Attachment metadata included on thread items.')).describe('Attachments associated with the user message. Defaults to an empty list.'),
  "inference_options": zod.object({
  "tool_choice": zod.object({
  "id": zod.string().describe('Identifier of the requested tool.')
}).describe('Tool selection that the assistant should honor when executing the item.').or(zod.null()),
  "model": zod.string().describe('Model name that generated the response. Defaults to null when using the session default.').or(zod.null())
}).describe('Model and tool overrides applied when generating the assistant response.').or(zod.null())
}).describe('User-authored messages within a thread.'),zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.assistant_message']).optional().describe('Type discriminator that is always `chatkit.assistant_message`.'),
  "content": zod.array(zod.object({
  "type": zod.enum(['output_text']).optional().describe('Type discriminator that is always `output_text`.'),
  "text": zod.string().describe('Assistant generated text.'),
  "annotations": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['file']).optional().describe('Type discriminator that is always `file` for this annotation.'),
  "source": zod.object({
  "type": zod.enum(['file']).optional().describe('Type discriminator that is always `file`.'),
  "filename": zod.string().describe('Filename referenced by the annotation.')
}).describe('Attachment source referenced by an annotation.')
}).describe('Annotation that references an uploaded file.'),zod.object({
  "type": zod.enum(['url']).optional().describe('Type discriminator that is always `url` for this annotation.'),
  "source": zod.object({
  "type": zod.enum(['url']).optional().describe('Type discriminator that is always `url`.'),
  "url": zod.string().describe('URL referenced by the annotation.')
}).describe('URL backing an annotation entry.')
}).describe('Annotation that references a URL.')]).describe('Annotation object describing a cited source.')).describe('Ordered list of annotations attached to the response text.')
}).describe('Assistant response text accompanied by optional annotations.')).describe('Ordered assistant response segments.')
}).describe('Assistant-authored message within a thread.'),zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.widget']).optional().describe('Type discriminator that is always `chatkit.widget`.'),
  "widget": zod.string().describe('Serialized widget payload rendered in the UI.')
}).describe('Thread item that renders a widget payload.'),zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.client_tool_call']).optional().describe('Type discriminator that is always `chatkit.client_tool_call`.'),
  "status": zod.enum(['in_progress', 'completed']),
  "call_id": zod.string().describe('Identifier for the client tool call.'),
  "name": zod.string().describe('Tool name that was invoked.'),
  "arguments": zod.string().describe('JSON-encoded arguments that were sent to the tool.'),
  "output": zod.string().describe('JSON-encoded output captured from the tool. Defaults to null while execution is in progress.').or(zod.null())
}).describe('Record of a client side tool invocation initiated by the assistant.'),zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.task']).optional().describe('Type discriminator that is always `chatkit.task`.'),
  "task_type": zod.enum(['custom', 'thought']),
  "heading": zod.string().describe('Optional heading for the task. Defaults to null when not provided.').or(zod.null()),
  "summary": zod.string().describe('Optional summary that describes the task. Defaults to null when omitted.').or(zod.null())
}).describe('Task emitted by the workflow to show progress and status updates.'),zod.object({
  "id": zod.string().describe('Identifier of the thread item.'),
  "object": zod.enum(['chatkit.thread_item']).optional().describe('Type discriminator that is always `chatkit.thread_item`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the item was created.'),
  "thread_id": zod.string().describe('Identifier of the parent thread.'),
  "type": zod.enum(['chatkit.task_group']).optional().describe('Type discriminator that is always `chatkit.task_group`.'),
  "tasks": zod.array(zod.object({
  "type": zod.enum(['custom', 'thought']),
  "heading": zod.string().describe('Optional heading for the grouped task. Defaults to null when not provided.').or(zod.null()),
  "summary": zod.string().describe('Optional summary that describes the grouped task. Defaults to null when omitted.').or(zod.null())
}).describe('Task entry that appears within a TaskGroup.')).describe('Tasks included in the group.')
}).describe('Collection of workflow tasks grouped together in the thread.')])).describe('A list of items'),
  "first_id": zod.string().describe('The ID of the first item in the list.').or(zod.null()),
  "last_id": zod.string().describe('The ID of the last item in the list.').or(zod.null()),
  "has_more": zod.boolean().describe('Whether there are more items available.')
}).describe('A paginated list of thread items rendered for the ChatKit API.')

/**
 * Retrieve a ChatKit thread
 * @summary Retrieve ChatKit thread
 */
export const getThreadMethodParams = zod.object({
  "thread_id": zod.string().describe('Identifier of the ChatKit thread to retrieve.')
})

export const getThreadMethodResponseObjectDefault = "chatkit.thread";export const getThreadMethodResponseStatusTypeDefault = "active";export const getThreadMethodResponseStatusTypeDefaultOne = "locked";export const getThreadMethodResponseStatusTypeDefaultTwo = "closed";

export const getThreadMethodResponse = zod.object({
  "id": zod.string().describe('Identifier of the thread.'),
  "object": zod.enum(['chatkit.thread']).optional().describe('Type discriminator that is always `chatkit.thread`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the thread was created.'),
  "title": zod.string().describe('Optional human-readable title for the thread. Defaults to null when no title has been generated.').or(zod.null()),
  "status": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['active']).optional().describe('Status discriminator that is always `active`.')
}).describe('Indicates that a thread is active.'),zod.object({
  "type": zod.enum(['locked']).optional().describe('Status discriminator that is always `locked`.'),
  "reason": zod.string().describe('Reason that the thread was locked. Defaults to null when no reason is recorded.').or(zod.null())
}).describe('Indicates that a thread is locked and cannot accept new input.'),zod.object({
  "type": zod.enum(['closed']).optional().describe('Status discriminator that is always `closed`.'),
  "reason": zod.string().describe('Reason that the thread was closed. Defaults to null when no reason is recorded.').or(zod.null())
}).describe('Indicates that a thread has been closed.')]).describe('Current status for the thread. Defaults to `active` for newly created threads.'),
  "user": zod.string().describe('Free-form string that identifies your end user who owns the thread.')
}).describe('Represents a ChatKit thread and its current status.')

/**
 * Delete a ChatKit thread
 * @summary Delete ChatKit thread
 */
export const deleteThreadMethodParams = zod.object({
  "thread_id": zod.string().describe('Identifier of the ChatKit thread to delete.')
})

export const deleteThreadMethodResponseObjectDefault = "chatkit.thread.deleted";

export const deleteThreadMethodResponse = zod.object({
  "id": zod.string().describe('Identifier of the deleted thread.'),
  "object": zod.enum(['chatkit.thread.deleted']).optional().describe('Type discriminator that is always `chatkit.thread.deleted`.'),
  "deleted": zod.boolean().describe('Indicates that the thread has been deleted.')
}).describe('Confirmation payload returned after deleting a thread.')

/**
 * List ChatKit threads
 * @summary List ChatKit threads
 */
export const listThreadsMethodQueryLimitMin = 0;

export const listThreadsMethodQueryLimitMax = 100;
export const listThreadsMethodQueryUserMax = 512;


export const listThreadsMethodQueryParams = zod.object({
  "limit": zod.number().min(listThreadsMethodQueryLimitMin).max(listThreadsMethodQueryLimitMax).optional().describe('Maximum number of thread items to return. Defaults to 20.'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order for results by creation time. Defaults to `desc`.'),
  "after": zod.string().optional().describe('List items created after this thread item ID. Defaults to null for the first page.'),
  "before": zod.string().optional().describe('List items created before this thread item ID. Defaults to null for the newest results.'),
  "user": zod.string().min(1).max(listThreadsMethodQueryUserMax).optional().describe('Filter threads that belong to this user identifier. Defaults to null to return all users.')
})

export const listThreadsMethodResponseObjectDefault = "list";export const listThreadsMethodResponseDataItemObjectDefault = "chatkit.thread";export const listThreadsMethodResponseDataItemStatusTypeDefault = "active";export const listThreadsMethodResponseDataItemStatusTypeDefaultOne = "locked";export const listThreadsMethodResponseDataItemStatusTypeDefaultTwo = "closed";

export const listThreadsMethodResponse = zod.object({
  "object": zod.any().optional().describe('The type of object returned, must be `list`.'),
  "data": zod.array(zod.object({
  "id": zod.string().describe('Identifier of the thread.'),
  "object": zod.enum(['chatkit.thread']).optional().describe('Type discriminator that is always `chatkit.thread`.'),
  "created_at": zod.number().describe('Unix timestamp (in seconds) for when the thread was created.'),
  "title": zod.string().describe('Optional human-readable title for the thread. Defaults to null when no title has been generated.').or(zod.null()),
  "status": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['active']).optional().describe('Status discriminator that is always `active`.')
}).describe('Indicates that a thread is active.'),zod.object({
  "type": zod.enum(['locked']).optional().describe('Status discriminator that is always `locked`.'),
  "reason": zod.string().describe('Reason that the thread was locked. Defaults to null when no reason is recorded.').or(zod.null())
}).describe('Indicates that a thread is locked and cannot accept new input.'),zod.object({
  "type": zod.enum(['closed']).optional().describe('Status discriminator that is always `closed`.'),
  "reason": zod.string().describe('Reason that the thread was closed. Defaults to null when no reason is recorded.').or(zod.null())
}).describe('Indicates that a thread has been closed.')]).describe('Current status for the thread. Defaults to `active` for newly created threads.'),
  "user": zod.string().describe('Free-form string that identifies your end user who owns the thread.')
}).describe('Represents a ChatKit thread and its current status.')).describe('A list of items'),
  "first_id": zod.string().describe('The ID of the first item in the list.').or(zod.null()),
  "last_id": zod.string().describe('The ID of the last item in the list.').or(zod.null()),
  "has_more": zod.boolean().describe('Whether there are more items available.')
}).describe('A paginated list of ChatKit threads.')

