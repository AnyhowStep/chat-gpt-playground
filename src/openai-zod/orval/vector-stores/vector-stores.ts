/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 * OpenAPI spec version: 2.3.0
 */
import {
  z as zod
} from 'zod';


/**
 * Returns a list of vector stores.
 * @summary List vector stores
 */
export const listVectorStoresQueryLimitDefault = 20;export const listVectorStoresQueryOrderDefault = "desc";

export const listVectorStoresQueryParams = zod.object({
  "limit": zod.number().optional().describe('A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n'),
  "after": zod.string().optional().describe('A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n'),
  "before": zod.string().optional().describe('A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n')
})

export const listVectorStoresResponseDataItemExpiresAfterDaysMax = 365;


export const listVectorStoresResponse = zod.object({
  "object": zod.string(),
  "data": zod.array(zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store']).describe('The object type, which is always `vector_store`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was created.'),
  "name": zod.string().describe('The name of the vector store.'),
  "usage_bytes": zod.number().describe('The total number of bytes used by the files in the vector store.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been successfully processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that were cancelled.'),
  "total": zod.number().describe('The total number of files.')
}),
  "status": zod.enum(['expired', 'in_progress', 'completed']).describe('The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(listVectorStoresResponseDataItemExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).optional().describe('The expiration policy for a vector store.'),
  "expires_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store will expire.').or(zod.null()).optional(),
  "last_active_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was last active.').or(zod.null()),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null())
}).describe('A vector store is a collection of processed files can be used by the `file_search` tool.')),
  "first_id": zod.string(),
  "last_id": zod.string(),
  "has_more": zod.boolean()
})

/**
 * Create a vector store.
 * @summary Create vector store
 */
export const createVectorStoreBodyFileIdsMax = 500;
export const createVectorStoreBodyExpiresAfterDaysMax = 365;
export const createVectorStoreBodyChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const createVectorStoreBodyChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;


export const createVectorStoreBody = zod.object({
  "file_ids": zod.array(zod.string()).max(createVectorStoreBodyFileIdsMax).optional().describe('A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.'),
  "name": zod.string().optional().describe('The name of the vector store.'),
  "description": zod.string().optional().describe('A description for the vector store. Can be used to describe the vector store\'s purpose.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(createVectorStoreBodyExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).optional().describe('The expiration policy for a vector store.'),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['auto']).describe('Always `auto`.')
}).describe('The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.'),zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(createVectorStoreBodyChunkingStrategyStaticMaxChunkSizeTokensMin).max(createVectorStoreBodyChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}).describe('Customize your own chunking strategy by setting chunk size and chunk overlap.')]).optional().describe('The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.'),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null()).optional()
})

export const createVectorStoreResponseExpiresAfterDaysMax = 365;


export const createVectorStoreResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store']).describe('The object type, which is always `vector_store`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was created.'),
  "name": zod.string().describe('The name of the vector store.'),
  "usage_bytes": zod.number().describe('The total number of bytes used by the files in the vector store.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been successfully processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that were cancelled.'),
  "total": zod.number().describe('The total number of files.')
}),
  "status": zod.enum(['expired', 'in_progress', 'completed']).describe('The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(createVectorStoreResponseExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).optional().describe('The expiration policy for a vector store.'),
  "expires_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store will expire.').or(zod.null()).optional(),
  "last_active_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was last active.').or(zod.null()),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null())
}).describe('A vector store is a collection of processed files can be used by the `file_search` tool.')

/**
 * Retrieves a vector store.
 * @summary Retrieve vector store
 */
export const getVectorStoreParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store to retrieve.')
})

export const getVectorStoreResponseExpiresAfterDaysMax = 365;


export const getVectorStoreResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store']).describe('The object type, which is always `vector_store`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was created.'),
  "name": zod.string().describe('The name of the vector store.'),
  "usage_bytes": zod.number().describe('The total number of bytes used by the files in the vector store.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been successfully processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that were cancelled.'),
  "total": zod.number().describe('The total number of files.')
}),
  "status": zod.enum(['expired', 'in_progress', 'completed']).describe('The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(getVectorStoreResponseExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).optional().describe('The expiration policy for a vector store.'),
  "expires_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store will expire.').or(zod.null()).optional(),
  "last_active_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was last active.').or(zod.null()),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null())
}).describe('A vector store is a collection of processed files can be used by the `file_search` tool.')

/**
 * Modifies a vector store.
 * @summary Modify vector store
 */
export const modifyVectorStoreParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store to modify.')
})

export const modifyVectorStoreBodyExpiresAfterDaysMax = 365;


export const modifyVectorStoreBody = zod.object({
  "name": zod.string().nullish().describe('The name of the vector store.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(modifyVectorStoreBodyExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).describe('The expiration policy for a vector store.').and(zod.any().nullable()).optional(),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null()).optional()
})

export const modifyVectorStoreResponseExpiresAfterDaysMax = 365;


export const modifyVectorStoreResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store']).describe('The object type, which is always `vector_store`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was created.'),
  "name": zod.string().describe('The name of the vector store.'),
  "usage_bytes": zod.number().describe('The total number of bytes used by the files in the vector store.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been successfully processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that were cancelled.'),
  "total": zod.number().describe('The total number of files.')
}),
  "status": zod.enum(['expired', 'in_progress', 'completed']).describe('The status of the vector store, which can be either `expired`, `in_progress`, or `completed`. A status of `completed` indicates that the vector store is ready for use.'),
  "expires_after": zod.object({
  "anchor": zod.enum(['last_active_at']).describe('Anchor timestamp after which the expiration policy applies. Supported anchors: `last_active_at`.'),
  "days": zod.number().min(1).max(modifyVectorStoreResponseExpiresAfterDaysMax).describe('The number of days after the anchor time that the vector store will expire.')
}).optional().describe('The expiration policy for a vector store.'),
  "expires_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store will expire.').or(zod.null()).optional(),
  "last_active_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store was last active.').or(zod.null()),
  "metadata": zod.record(zod.string(), zod.string()).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard.\n\nKeys are strings with a maximum length of 64 characters. Values are strings\nwith a maximum length of 512 characters.\n').or(zod.null())
}).describe('A vector store is a collection of processed files can be used by the `file_search` tool.')

/**
 * Delete a vector store.
 * @summary Delete vector store
 */
export const deleteVectorStoreParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store to delete.')
})

export const deleteVectorStoreResponse = zod.object({
  "id": zod.string(),
  "deleted": zod.boolean(),
  "object": zod.enum(['vector_store.deleted'])
})

/**
 * Create a vector store file batch.
 * @summary Create vector store file batch
 */
export const createVectorStoreFileBatchParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store for which to create a File Batch.\n')
})

export const createVectorStoreFileBatchBodyFileIdsMax = 500;
export const createVectorStoreFileBatchBodyChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const createVectorStoreFileBatchBodyChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const createVectorStoreFileBatchBodyAttributesMaxThree = 512;


export const createVectorStoreFileBatchBody = zod.object({
  "file_ids": zod.array(zod.string()).min(1).max(createVectorStoreFileBatchBodyFileIdsMax).describe('A list of [File](https://platform.openai.com/docs/api-reference/files) IDs that the vector store should use. Useful for tools like `file_search` that can access files.'),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['auto']).describe('Always `auto`.')
}).describe('The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.'),zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(createVectorStoreFileBatchBodyChunkingStrategyStaticMaxChunkSizeTokensMin).max(createVectorStoreFileBatchBodyChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}).describe('Customize your own chunking strategy by setting chunk size and chunk overlap.')]).optional().describe('The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.'),
  "attributes": zod.record(zod.string(), zod.string().max(createVectorStoreFileBatchBodyAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
})

export const createVectorStoreFileBatchResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.files_batch']).describe('The object type, which is always `vector_store.file_batch`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store files batch was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that where cancelled.'),
  "total": zod.number().describe('The total number of files.')
})
}).describe('A batch of files attached to a vector store.')

/**
 * Retrieves a vector store file batch.
 * @summary Retrieve vector store file batch
 */
export const getVectorStoreFileBatchParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the file batch belongs to.'),
  "batch_id": zod.string().describe('The ID of the file batch being retrieved.')
})

export const getVectorStoreFileBatchResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.files_batch']).describe('The object type, which is always `vector_store.file_batch`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store files batch was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that where cancelled.'),
  "total": zod.number().describe('The total number of files.')
})
}).describe('A batch of files attached to a vector store.')

/**
 * Cancel a vector store file batch. This attempts to cancel the processing of files in this batch as soon as possible.
 * @summary Cancel vector store file batch
 */
export const cancelVectorStoreFileBatchParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the file batch belongs to.'),
  "batch_id": zod.string().describe('The ID of the file batch to cancel.')
})

export const cancelVectorStoreFileBatchResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.files_batch']).describe('The object type, which is always `vector_store.file_batch`.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store files batch was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store files batch, which can be either `in_progress`, `completed`, `cancelled` or `failed`.'),
  "file_counts": zod.object({
  "in_progress": zod.number().describe('The number of files that are currently being processed.'),
  "completed": zod.number().describe('The number of files that have been processed.'),
  "failed": zod.number().describe('The number of files that have failed to process.'),
  "cancelled": zod.number().describe('The number of files that where cancelled.'),
  "total": zod.number().describe('The total number of files.')
})
}).describe('A batch of files attached to a vector store.')

/**
 * Returns a list of vector store files in a batch.
 * @summary List vector store files in a batch
 */
export const listFilesInVectorStoreBatchParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the files belong to.'),
  "batch_id": zod.string().describe('The ID of the file batch that the files belong to.')
})

export const listFilesInVectorStoreBatchQueryLimitDefault = 20;export const listFilesInVectorStoreBatchQueryOrderDefault = "desc";

export const listFilesInVectorStoreBatchQueryParams = zod.object({
  "limit": zod.number().optional().describe('A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n'),
  "after": zod.string().optional().describe('A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n'),
  "before": zod.string().optional().describe('A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n'),
  "filter": zod.enum(['in_progress', 'completed', 'failed', 'cancelled']).optional().describe('Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.')
})

export const listFilesInVectorStoreBatchResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const listFilesInVectorStoreBatchResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const listFilesInVectorStoreBatchResponseDataItemAttributesMaxThree = 512;


export const listFilesInVectorStoreBatchResponse = zod.object({
  "object": zod.string(),
  "data": zod.array(zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.file']).describe('The object type, which is always `vector_store.file`.'),
  "usage_bytes": zod.number().describe('The total vector store usage in bytes. Note that this may be different from the original file size.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store file was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.'),
  "last_error": zod.object({
  "code": zod.enum(['server_error', 'unsupported_file', 'invalid_file']).describe('One of `server_error`, `unsupported_file`, or `invalid_file`.'),
  "message": zod.string().describe('A human-readable description of the error.')
}).describe('The last error associated with this vector store file. Will be `null` if there are no errors.').or(zod.null()),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(listFilesInVectorStoreBatchResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMin).max(listFilesInVectorStoreBatchResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}),zod.object({
  "type": zod.enum(['other']).describe('Always `other`.')
}).describe('This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.')]).optional().describe('The strategy used to chunk the file.'),
  "attributes": zod.record(zod.string(), zod.string().max(listFilesInVectorStoreBatchResponseDataItemAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
}).describe('A list of files attached to a vector store.')),
  "first_id": zod.string(),
  "last_id": zod.string(),
  "has_more": zod.boolean()
})

/**
 * Returns a list of vector store files.
 * @summary List vector store files
 */
export const listVectorStoreFilesParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the files belong to.')
})

export const listVectorStoreFilesQueryLimitDefault = 20;export const listVectorStoreFilesQueryOrderDefault = "desc";

export const listVectorStoreFilesQueryParams = zod.object({
  "limit": zod.number().optional().describe('A limit on the number of objects to be returned. Limit can range between 1 and 100, and the default is 20.\n'),
  "order": zod.enum(['asc', 'desc']).optional().describe('Sort order by the `created_at` timestamp of the objects. `asc` for ascending order and `desc` for descending order.\n'),
  "after": zod.string().optional().describe('A cursor for use in pagination. `after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, ending with obj_foo, your subsequent call can include after=obj_foo in order to fetch the next page of the list.\n'),
  "before": zod.string().optional().describe('A cursor for use in pagination. `before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 100 objects, starting with obj_foo, your subsequent call can include before=obj_foo in order to fetch the previous page of the list.\n'),
  "filter": zod.enum(['in_progress', 'completed', 'failed', 'cancelled']).optional().describe('Filter by file status. One of `in_progress`, `completed`, `failed`, `cancelled`.')
})

export const listVectorStoreFilesResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const listVectorStoreFilesResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const listVectorStoreFilesResponseDataItemAttributesMaxThree = 512;


export const listVectorStoreFilesResponse = zod.object({
  "object": zod.string(),
  "data": zod.array(zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.file']).describe('The object type, which is always `vector_store.file`.'),
  "usage_bytes": zod.number().describe('The total vector store usage in bytes. Note that this may be different from the original file size.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store file was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.'),
  "last_error": zod.object({
  "code": zod.enum(['server_error', 'unsupported_file', 'invalid_file']).describe('One of `server_error`, `unsupported_file`, or `invalid_file`.'),
  "message": zod.string().describe('A human-readable description of the error.')
}).describe('The last error associated with this vector store file. Will be `null` if there are no errors.').or(zod.null()),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(listVectorStoreFilesResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMin).max(listVectorStoreFilesResponseDataItemChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}),zod.object({
  "type": zod.enum(['other']).describe('Always `other`.')
}).describe('This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.')]).optional().describe('The strategy used to chunk the file.'),
  "attributes": zod.record(zod.string(), zod.string().max(listVectorStoreFilesResponseDataItemAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
}).describe('A list of files attached to a vector store.')),
  "first_id": zod.string(),
  "last_id": zod.string(),
  "has_more": zod.boolean()
})

/**
 * Create a vector store file by attaching a [File](https://platform.openai.com/docs/api-reference/files) to a [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
 * @summary Create vector store file
 */
export const createVectorStoreFileParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store for which to create a File.\n')
})

export const createVectorStoreFileBodyChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const createVectorStoreFileBodyChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const createVectorStoreFileBodyAttributesMaxThree = 512;


export const createVectorStoreFileBody = zod.object({
  "file_id": zod.string().describe('A [File](https://platform.openai.com/docs/api-reference/files) ID that the vector store should use. Useful for tools like `file_search` that can access files.'),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['auto']).describe('Always `auto`.')
}).describe('The default strategy. This strategy currently uses a `max_chunk_size_tokens` of `800` and `chunk_overlap_tokens` of `400`.'),zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(createVectorStoreFileBodyChunkingStrategyStaticMaxChunkSizeTokensMin).max(createVectorStoreFileBodyChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}).describe('Customize your own chunking strategy by setting chunk size and chunk overlap.')]).optional().describe('The chunking strategy used to chunk the file(s). If not set, will use the `auto` strategy. Only applicable if `file_ids` is non-empty.'),
  "attributes": zod.record(zod.string(), zod.string().max(createVectorStoreFileBodyAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
})

export const createVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const createVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const createVectorStoreFileResponseAttributesMaxThree = 512;


export const createVectorStoreFileResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.file']).describe('The object type, which is always `vector_store.file`.'),
  "usage_bytes": zod.number().describe('The total vector store usage in bytes. Note that this may be different from the original file size.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store file was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.'),
  "last_error": zod.object({
  "code": zod.enum(['server_error', 'unsupported_file', 'invalid_file']).describe('One of `server_error`, `unsupported_file`, or `invalid_file`.'),
  "message": zod.string().describe('A human-readable description of the error.')
}).describe('The last error associated with this vector store file. Will be `null` if there are no errors.').or(zod.null()),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(createVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMin).max(createVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}),zod.object({
  "type": zod.enum(['other']).describe('Always `other`.')
}).describe('This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.')]).optional().describe('The strategy used to chunk the file.'),
  "attributes": zod.record(zod.string(), zod.string().max(createVectorStoreFileResponseAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
}).describe('A list of files attached to a vector store.')

/**
 * Retrieves a vector store file.
 * @summary Retrieve vector store file
 */
export const getVectorStoreFileParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the file belongs to.'),
  "file_id": zod.string().describe('The ID of the file being retrieved.')
})

export const getVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const getVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const getVectorStoreFileResponseAttributesMaxThree = 512;


export const getVectorStoreFileResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.file']).describe('The object type, which is always `vector_store.file`.'),
  "usage_bytes": zod.number().describe('The total vector store usage in bytes. Note that this may be different from the original file size.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store file was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.'),
  "last_error": zod.object({
  "code": zod.enum(['server_error', 'unsupported_file', 'invalid_file']).describe('One of `server_error`, `unsupported_file`, or `invalid_file`.'),
  "message": zod.string().describe('A human-readable description of the error.')
}).describe('The last error associated with this vector store file. Will be `null` if there are no errors.').or(zod.null()),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(getVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMin).max(getVectorStoreFileResponseChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}),zod.object({
  "type": zod.enum(['other']).describe('Always `other`.')
}).describe('This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.')]).optional().describe('The strategy used to chunk the file.'),
  "attributes": zod.record(zod.string(), zod.string().max(getVectorStoreFileResponseAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
}).describe('A list of files attached to a vector store.')

/**
 * Delete a vector store file. This will remove the file from the vector store but the file itself will not be deleted. To delete the file, use the [delete file](https://platform.openai.com/docs/api-reference/files/delete) endpoint.
 * @summary Delete vector store file
 */
export const deleteVectorStoreFileParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store that the file belongs to.'),
  "file_id": zod.string().describe('The ID of the file to delete.')
})

export const deleteVectorStoreFileResponse = zod.object({
  "id": zod.string(),
  "deleted": zod.boolean(),
  "object": zod.enum(['vector_store.file.deleted'])
})

/**
 * Update attributes on a vector store file.
 * @summary Update vector store file attributes
 */
export const updateVectorStoreFileAttributesParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store the file belongs to.'),
  "file_id": zod.string().describe('The ID of the file to update attributes.')
})

export const updateVectorStoreFileAttributesBodyAttributesMaxThree = 512;


export const updateVectorStoreFileAttributesBody = zod.object({
  "attributes": zod.record(zod.string(), zod.string().max(updateVectorStoreFileAttributesBodyAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null())
})

export const updateVectorStoreFileAttributesResponseChunkingStrategyStaticMaxChunkSizeTokensMin = 100;

export const updateVectorStoreFileAttributesResponseChunkingStrategyStaticMaxChunkSizeTokensMax = 4096;
export const updateVectorStoreFileAttributesResponseAttributesMaxThree = 512;


export const updateVectorStoreFileAttributesResponse = zod.object({
  "id": zod.string().describe('The identifier, which can be referenced in API endpoints.'),
  "object": zod.enum(['vector_store.file']).describe('The object type, which is always `vector_store.file`.'),
  "usage_bytes": zod.number().describe('The total vector store usage in bytes. Note that this may be different from the original file size.'),
  "created_at": zod.number().describe('The Unix timestamp (in seconds) for when the vector store file was created.'),
  "vector_store_id": zod.string().describe('The ID of the [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object) that the [File](https://platform.openai.com/docs/api-reference/files) is attached to.'),
  "status": zod.enum(['in_progress', 'completed', 'cancelled', 'failed']).describe('The status of the vector store file, which can be either `in_progress`, `completed`, `cancelled`, or `failed`. The status `completed` indicates that the vector store file is ready for use.'),
  "last_error": zod.object({
  "code": zod.enum(['server_error', 'unsupported_file', 'invalid_file']).describe('One of `server_error`, `unsupported_file`, or `invalid_file`.'),
  "message": zod.string().describe('A human-readable description of the error.')
}).describe('The last error associated with this vector store file. Will be `null` if there are no errors.').or(zod.null()),
  "chunking_strategy": zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['static']).describe('Always `static`.'),
  "static": zod.object({
  "max_chunk_size_tokens": zod.number().min(updateVectorStoreFileAttributesResponseChunkingStrategyStaticMaxChunkSizeTokensMin).max(updateVectorStoreFileAttributesResponseChunkingStrategyStaticMaxChunkSizeTokensMax).describe('The maximum number of tokens in each chunk. The default value is `800`. The minimum value is `100` and the maximum value is `4096`.'),
  "chunk_overlap_tokens": zod.number().describe('The number of tokens that overlap between chunks. The default value is `400`.\n\nNote that the overlap must not exceed half of `max_chunk_size_tokens`.\n')
})
}),zod.object({
  "type": zod.enum(['other']).describe('Always `other`.')
}).describe('This is returned when the chunking strategy is unknown. Typically, this is because the file was indexed before the `chunking_strategy` concept was introduced in the API.')]).optional().describe('The strategy used to chunk the file.'),
  "attributes": zod.record(zod.string(), zod.string().max(updateVectorStoreFileAttributesResponseAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()).optional()
}).describe('A list of files attached to a vector store.')

/**
 * Retrieve the parsed contents of a vector store file.
 * @summary Retrieve vector store file content
 */
export const retrieveVectorStoreFileContentParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store.'),
  "file_id": zod.string().describe('The ID of the file within the vector store.')
})

export const retrieveVectorStoreFileContentResponse = zod.object({
  "object": zod.enum(['vector_store.file_content.page']).describe('The object type, which is always `vector_store.file_content.page`'),
  "data": zod.array(zod.object({
  "type": zod.string().optional().describe('The content type (currently only `\"text\"`)'),
  "text": zod.string().optional().describe('The text content')
})).describe('Parsed content of the file.'),
  "has_more": zod.boolean().describe('Indicates if there are more content pages to fetch.'),
  "next_page": zod.string().describe('The token for the next page, if any.').or(zod.null())
}).describe('Represents the parsed content of a vector store file.')

/**
 * Search a vector store for relevant chunks based on a query and file attributes filter.
 * @summary Search vector store
 */
export const searchVectorStoreParams = zod.object({
  "vector_store_id": zod.string().describe('The ID of the vector store to search.')
})

export const searchVectorStoreBodyRewriteQueryDefault = false;export const searchVectorStoreBodyMaxNumResultsDefault = 10;
export const searchVectorStoreBodyMaxNumResultsMax = 50;
export const searchVectorStoreBodyFiltersTypeDefault = "eq";export const searchVectorStoreBodyFiltersFiltersItemTypeDefault = "eq";export const searchVectorStoreBodyRankingOptionsRankerDefault = "auto";export const searchVectorStoreBodyRankingOptionsScoreThresholdDefault = 0;
export const searchVectorStoreBodyRankingOptionsScoreThresholdMin = 0;

export const searchVectorStoreBodyRankingOptionsScoreThresholdMax = 1;


export const searchVectorStoreBody = zod.object({
  "query": zod.string().or(zod.array(zod.string().min(1).describe('A list of queries to search for.'))).describe('A query string for a search'),
  "rewrite_query": zod.boolean().optional().describe('Whether to rewrite the natural language query for vector search.'),
  "max_num_results": zod.number().min(1).max(searchVectorStoreBodyMaxNumResultsMax).optional().describe('The maximum number of results to return. This number should be between 1 and 50 inclusive.'),
  "filters": zod.object({
  "type": zod.enum(['eq', 'ne', 'gt', 'gte', 'lt', 'lte']).optional().describe('Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n'),
  "key": zod.string().describe('The key to compare against the value.'),
  "value": zod.string().or(zod.number()).or(zod.boolean()).or(zod.array(zod.string().or(zod.number()))).describe('The value to compare against the attribute key; supports string, number, or boolean types.')
}).describe('A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n').or(zod.object({
  "type": zod.enum(['and', 'or']).describe('Type of operation: `and` or `or`.'),
  "filters": zod.array(zod.discriminatedUnion('type', [zod.object({
  "type": zod.enum(['eq', 'ne', 'gt', 'gte', 'lt', 'lte']).optional().describe('Specifies the comparison operator: `eq`, `ne`, `gt`, `gte`, `lt`, `lte`, `in`, `nin`.\n- `eq`: equals\n- `ne`: not equal\n- `gt`: greater than\n- `gte`: greater than or equal\n- `lt`: less than\n- `lte`: less than or equal\n- `in`: in\n- `nin`: not in\n'),
  "key": zod.string().describe('The key to compare against the value.'),
  "value": zod.string().or(zod.number()).or(zod.boolean()).or(zod.array(zod.string().or(zod.number()))).describe('The value to compare against the attribute key; supports string, number, or boolean types.')
}).describe('A filter used to compare a specified attribute key to a given value using a defined comparison operation.\n'),.any()])).describe('Array of filters to combine. Items can be `ComparisonFilter` or `CompoundFilter`.')
}).describe('Combine multiple filters using `and` or `or`.')).optional().describe('A filter to apply based on file attributes.'),
  "ranking_options": zod.object({
  "ranker": zod.enum(['none', 'auto', 'default-2024-11-15']).optional().describe('Enable re-ranking; set to `none` to disable, which can help reduce latency.'),
  "score_threshold": zod.number().min(searchVectorStoreBodyRankingOptionsScoreThresholdMin).max(searchVectorStoreBodyRankingOptionsScoreThresholdMax).optional()
}).optional().describe('Ranking options for search.')
})

export const searchVectorStoreResponseDataItemScoreMin = 0;

export const searchVectorStoreResponseDataItemScoreMax = 1;
export const searchVectorStoreResponseDataItemAttributesMaxThree = 512;


export const searchVectorStoreResponse = zod.object({
  "object": zod.enum(['vector_store.search_results.page']).describe('The object type, which is always `vector_store.search_results.page`'),
  "search_query": zod.array(zod.string().min(1).describe('The query used for this search.')),
  "data": zod.array(zod.object({
  "file_id": zod.string().describe('The ID of the vector store file.'),
  "filename": zod.string().describe('The name of the vector store file.'),
  "score": zod.number().min(searchVectorStoreResponseDataItemScoreMin).max(searchVectorStoreResponseDataItemScoreMax).describe('The similarity score for the result.'),
  "attributes": zod.record(zod.string(), zod.string().max(searchVectorStoreResponseDataItemAttributesMaxThree).or(zod.number()).or(zod.boolean())).describe('Set of 16 key-value pairs that can be attached to an object. This can be\nuseful for storing additional information about the object in a structured\nformat, and querying for objects via API or the dashboard. Keys are strings\nwith a maximum length of 64 characters. Values are strings with a maximum\nlength of 512 characters, booleans, or numbers.\n').or(zod.null()),
  "content": zod.array(zod.object({
  "type": zod.enum(['text']).describe('The type of content.'),
  "text": zod.string().describe('The text content returned from search.')
})).describe('Content chunks from the file.')
})).describe('The list of search result items.'),
  "has_more": zod.boolean().describe('Indicates if there are more results to fetch.'),
  "next_page": zod.string().describe('The token for the next page, if any.').or(zod.null())
})

