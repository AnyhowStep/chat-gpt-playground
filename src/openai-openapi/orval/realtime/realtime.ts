/**
 * Generated by orval v7.7.0 ðŸº
 * Do not edit manually.
 * OpenAI API
 * The OpenAI REST API. Please see https://platform.openai.com/docs/api-reference for more details.
 * OpenAPI spec version: 2.3.0
 */
import * as axios from 'axios';
import type {
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import type {
  RealtimeCallCreateRequest,
  RealtimeCallReferRequest,
  RealtimeCallRejectRequest,
  RealtimeCreateClientSecretRequest,
  RealtimeCreateClientSecretResponse,
  RealtimeSessionCreateRequest,
  RealtimeSessionCreateRequestGA,
  RealtimeSessionCreateResponse,
  RealtimeTranscriptionSessionCreateRequest,
  RealtimeTranscriptionSessionCreateResponse
} from '.././schema';




  export const getRealtime = () => {
/**
 * Create a new Realtime API call over WebRTC and receive the SDP answer needed
to complete the peer connection.
 * @summary Create call
 */
const createRealtimeCall = <TData = AxiosResponse<string>>(
    createRealtimeCallBody: RealtimeCallCreateRequest | string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/calls`,
      createRealtimeCallBody,options
    );
  }
/**
 * Accept an incoming SIP call and configure the realtime session that will
handle it.
 * @summary Accept call
 */
const acceptRealtimeCall = <TData = AxiosResponse<void>>(
    callId: string,
    realtimeSessionCreateRequestGA: RealtimeSessionCreateRequestGA, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/calls/${callId}/accept`,
      realtimeSessionCreateRequestGA,options
    );
  }
/**
 * End an active Realtime API call, whether it was initiated over SIP or
WebRTC.
 * @summary Hang up call
 */
const hangupRealtimeCall = <TData = AxiosResponse<void>>(
    callId: string, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/calls/${callId}/hangup`,undefined,options
    );
  }
/**
 * Transfer an active SIP call to a new destination using the SIP REFER verb.
 * @summary Refer call
 */
const referRealtimeCall = <TData = AxiosResponse<void>>(
    callId: string,
    realtimeCallReferRequest: RealtimeCallReferRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/calls/${callId}/refer`,
      realtimeCallReferRequest,options
    );
  }
/**
 * Decline an incoming SIP call by returning a SIP status code to the caller.
 * @summary Reject call
 */
const rejectRealtimeCall = <TData = AxiosResponse<void>>(
    callId: string,
    realtimeCallRejectRequest?: RealtimeCallRejectRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/calls/${callId}/reject`,
      realtimeCallRejectRequest,options
    );
  }
/**
 * Create a Realtime client secret with an associated session configuration.

 * @summary Create client secret
 */
const createRealtimeClientSecret = <TData = AxiosResponse<RealtimeCreateClientSecretResponse>>(
    realtimeCreateClientSecretRequest: RealtimeCreateClientSecretRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/client_secrets`,
      realtimeCreateClientSecretRequest,options
    );
  }
/**
 * Create an ephemeral API token for use in client-side applications with the
Realtime API. Can be configured with the same session parameters as the
`session.update` client event.

It responds with a session object, plus a `client_secret` key which contains
a usable ephemeral API token that can be used to authenticate browser clients
for the Realtime API.

 * @summary Create session
 */
const createRealtimeSession = <TData = AxiosResponse<RealtimeSessionCreateResponse>>(
    realtimeSessionCreateRequest: RealtimeSessionCreateRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/sessions`,
      realtimeSessionCreateRequest,options
    );
  }
/**
 * Create an ephemeral API token for use in client-side applications with the
Realtime API specifically for realtime transcriptions.
Can be configured with the same session parameters as the `transcription_session.update` client event.

It responds with a session object, plus a `client_secret` key which contains
a usable ephemeral API token that can be used to authenticate browser clients
for the Realtime API.

 * @summary Create transcription session
 */
const createRealtimeTranscriptionSession = <TData = AxiosResponse<RealtimeTranscriptionSessionCreateResponse>>(
    realtimeTranscriptionSessionCreateRequest: RealtimeTranscriptionSessionCreateRequest, options?: AxiosRequestConfig
 ): Promise<TData> => {
    return axios.default.post(
      `/realtime/transcription_sessions`,
      realtimeTranscriptionSessionCreateRequest,options
    );
  }
return {createRealtimeCall,acceptRealtimeCall,hangupRealtimeCall,referRealtimeCall,rejectRealtimeCall,createRealtimeClientSecret,createRealtimeSession,createRealtimeTranscriptionSession}};
export type CreateRealtimeCallResult = AxiosResponse<string>
export type AcceptRealtimeCallResult = AxiosResponse<void>
export type HangupRealtimeCallResult = AxiosResponse<void>
export type ReferRealtimeCallResult = AxiosResponse<void>
export type RejectRealtimeCallResult = AxiosResponse<void>
export type CreateRealtimeClientSecretResult = AxiosResponse<RealtimeCreateClientSecretResponse>
export type CreateRealtimeSessionResult = AxiosResponse<RealtimeSessionCreateResponse>
export type CreateRealtimeTranscriptionSessionResult = AxiosResponse<RealtimeTranscriptionSessionCreateResponse>
